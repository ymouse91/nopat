<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Dice Deduction</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#16213e">
  <meta property="og:image" content="https://ymouse91.github.io/nopat/icon-192.png">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="./icon-192.png">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: calc(env(safe-area-inset-top) + 12px) 12px calc(env(safe-area-inset-bottom) + 16px);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      width: min(900px, 99vw);
    }

    h1 {
      font-size: 28px;
      font-weight: 800;
      text-align: center;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      align-items: center;
    }

    
    .controls select{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color: #fff;
      outline: none;
    }
    .controls select option{ color: #000; }
    button {
      padding: 10px 14px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      color: #000;
      transition: transform 0.2s;
    }

    button:active {
      transform: scale(0.95);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .board-wrapper {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
	
.boardframe {
  display: grid;
  position: relative;

  --gap: 4px;
  --pad: 12px;

  /* YHTEINEN solukoko: sama arvo gridille ja ristin laskennalle */
  --cell: calc((100% - (var(--pad) * 2) - (var(--gap) * 6)) / 7);

  /* Ã„LÃ„ kÃ¤ytÃ¤ 1fr â†’ fr-pyÃ¶ristys siirtÃ¤Ã¤ ristiÃ¤ joillain leveyksillÃ¤ */
  grid-template-columns: repeat(7, var(--cell));
  grid-template-rows: repeat(7, var(--cell));

  gap: var(--gap);
  background: rgba(0, 0, 0, 0.3);
  padding: var(--pad);
  border-radius: 14px;
  width: min(420px, 95vw);
  aspect-ratio: 1;
}

/* Clear cross to separate the four 3Ã—3 dice areas INSIDE the 6Ã—6 play area.
   NOTE: The board is a 7Ã—7 grid (last row/col are hint cells). The cross must NOT extend
   into the hint row/col, so we draw two absolute lines sized to the 6Ã—6 area only. */
.boardframe::before,
.boardframe::after{
  content:"";
  position:absolute;
  pointer-events:none;

  /* kÃ¤ytÃ¤ samaa --cell:ia joka on .boardframe:ssÃ¤ */
  --play:  calc((var(--cell) * 6) + (var(--gap) * 5));
  /* sama kuin 3*cell + 2.5*gap, mutta vakaampi laskenta */
  --split: calc((var(--cell) * 3) + (var(--gap) * 2) + (var(--gap) / 2));
  --w: 4px;

  background: rgba(0, 212, 255, 1);
  opacity: 0.85;
  border-radius: 999px;
  --nx: -10px;   /* hienosÃ¤Ã¤tÃ¶ X (kokeile 0px, 1px, 2px) */
  --ny: -11px;   /* hienosÃ¤Ã¤tÃ¶ Y */

}

/* vertical line (between columns 2 and 3 of the 6Ã—6 play area) */
.boardframe::before{
  left: calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--nx));
  top:  calc(var(--pad) + var(--ny));
  width: var(--w);
  height: var(--play);
}

.boardframe::after{
  left: calc(var(--pad) + var(--nx));
  top:  calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--ny));
  width: var(--play);
  height: var(--w);
}


/* Visual divider between the four 3Ã—3 dice areas */
.cell {
  aspect-ratio: 1;
  background: rgba(255, 255, 255, 0.08);
  border: 2px solid rgba(255, 255, 255, 0.15);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  position: relative;
  transition: all 0.2s;
  user-select: none;
}


    .cell:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
    }

    .cell.occupied {
      background: rgba(0, 212, 255, 0.15);
      border-color: rgba(0, 212, 255, 0.4);
    }

    
    
    /* Piece outline: draw border only on edges where neighboring cell is not same piece */
    .cell.piece { position: relative; }
    .cell.piece::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-top: var(--pt, 0px) solid rgba(255,255,255,0.75);
      border-right: var(--pr, 0px) solid rgba(255,255,255,0.75);
      border-bottom: var(--pb, 0px) solid rgba(255,255,255,0.75);
      border-left: var(--pl, 0px) solid rgba(255,255,255,0.75);
      border-radius: 6px;
      pointer-events:none;
    }
.hint {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.06);
      border: 2px dashed rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0.2px;
      user-select: none;
    }
    .hint.empty {
      background: transparent;
      border-color: transparent;
    }

    .hint.ok {
      background: rgba(0, 212, 255, 0.18);
      border-style: solid;
      border-color: rgba(0, 212, 255, 0.6);
    }
    .hint.bad {
      background: rgba(255, 80, 80, 0.18);
      border-style: solid;
      border-color: rgba(255, 80, 80, 0.6);
    }
    .pieces-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px;
	  min-width: 300px;
    }

.pieces-grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* AINA 3 saraketta */
  gap: 8px;
}


    .piece-btn {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 0.2s;
      position: relative;
      padding: 4px;
    }

    .piece-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .piece-btn.selected {
      background: rgba(0, 212, 255, 0.3);
      border-color: rgba(0, 212, 255, 0.8);
      box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
    }

    .piece-btn.used {
      opacity: 0.3;
      cursor: not-allowed;
    }

.piece-preview{
  --pv: 16px; /* PC + iPad oletus */
  display: grid;
  grid-template-columns: repeat(var(--cols), var(--pv));
  grid-auto-rows: var(--pv);
  gap: 2px;
   place-content: center; /* = align-content + justify-content */
}


    .piece-preview-cell {
      width: 16px;
      height: 16px;
      background: rgba(0, 212, 255, 0.5);
      border-radius: 2px;
    }

    .piece-preview-cell.empty {
      width: 16px;
      height: 16px;
    }

.piece-preview-cell.dot {
  position: relative;          /* pakollinen */
  background: #00d4ff;
}

.piece-preview-cell.dot::after {
  content: "";
  position: absolute;

  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  width: 6px;
  height: 6px;

  background: #000;
  border-radius: 50%;
}




    .piece-info {
      font-size: 11px;
      opacity: 0.7;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 16px;
      font-size: 13px;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.08);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .stat-label {
      opacity: 0.7;
      font-size: 11px;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 800;
      color: #00d4ff;
      margin-top: 4px;
    }

    .info-text {
      font-size: 13px;
      opacity: 0.7;
      margin-top: 12px;
      line-height: 1.5;
    }
	
	
	
	/* iPad / tablet: palat oikealle, 3Ã—4 ruudukko */
@media (min-width: 900px) {
  .board-wrapper{
    flex-wrap: nowrap;
    align-items: flex-start;
    justify-content: center;
    gap: 16px;
  }



  .pieces-grid{
    grid-template-columns: repeat(3, 1fr); /* 3 pysty-saraketta */
    gap: 8px;
  }

  .piece-btn{
    min-height: 70px;             /* sopiva iPadille */
    padding: 6px;
  }

  .piece-preview{
    width: 48px;
    height: 48px;
  }
}

@media (max-width: 520px){

  /* tiukempi sivureuna */
  body{
    padding-left: 4px;
    padding-right: 4px;
    overflow-x: hidden; /* varmistus */
  }

  .container{
    width: 100%;
  }

  .panel{
    padding: 10px;
  }

  /* palat alle + wrapper ei saa olla kapeampi kuin nÃ¤kymÃ¤ */
  .board-wrapper{
    width: 100%;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  /* TÃ„RKEÃ„: lauta ei saa nojata vw-laskuihin mobiilissa */
  .boardframe{
    width: calc(100vw - 8px);
    max-width: 100%;
    --pad: 6px;   /* oli 12px */
    --gap: 3px;   /* oli 4px */
  }

  .boardframe::before,
  .boardframe::after{
    --nx: -5px;
    --ny: -5px;
  }
  /* estÃ¤ pieces-panelia venyttÃ¤mÃ¤stÃ¤ leveyttÃ¤ */
  .pieces-panel{
    min-width: 0;      /* kumoaa 240px mobiilissa */
    width: 100%;
    max-width: 100%;
  }

  /* 6 saraketta -> 2 riviÃ¤, minmax estÃ¤Ã¤ valumisen */
  .pieces-grid{
    width: 100%;
    max-width: 100%;
    grid-template-columns: repeat(6, minmax(0, 1fr));
    gap: 4px;
  }

  /* grid-itemit saa kutistua */
  .piece-btn{
    min-width: 0;
    padding: 2px;
    border-radius: 6px;
  }

  /* miniatyyrit pieneksi */
  .piece-preview{
    --pv: 7px;
    grid-template-columns: repeat(var(--cols), var(--pv)) !important; /* ohittaa inline 16px */
    grid-auto-rows: var(--pv);
    gap: 1px;
    justify-content: start;
    align-content: start;
    max-width: 100%;
  }

  .piece-preview-cell,
  .piece-preview-cell.empty{
    width: var(--pv);
    height: var(--pv);
    margin: 0;
  }

  .piece-preview-cell.dot::after{
    width: 3px;
    height: 3px;
  }

  .hint{
    font-size: 12px;
    letter-spacing: 0.1px;
  }

  /* xo/ox pois + otsikko pois */
  .piece-info{ display:none; }
  .pieces-panel > div:first-child{ display:none; }
  
      .controls select{
      padding: 8px 10px;
      border-radius: 4px;

    }

    button {
      padding: 8px 10px;
      border: none;
      border-radius: 5px;
      font-weight: 700;
      font-size: 10px;

    }
	    h1 {
      font-size: 20px;
      margin-bottom: 10px;
    }
}



  </style>
</head>

<body>
<div class="container">
  <h1>ðŸŽ² Nokkelat nopat</h1>
  
  <div class="panel">
    <div class="controls">



      <label style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:12px; opacity:.85;">Pulma:</span>
        <select id="puzzleSelect" aria-label="Puzzle selector"></select>
      </label>
	        <button id="resetBtn">Nollaa</button>
    </div>

<div class="board-wrapper">
  <div class="boardframe" id="boardFrame"></div>

  <div class="pieces-panel">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 12px;">Palat</div>
    <div class="pieces-grid" id="piecesGrid"></div>
  </div>
</div>

	
<div hidden>
    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Top-Left</div>
        <div class="stat-value" id="area0">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Top-Right</div>
        <div class="stat-value" id="area1">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Bottom-Left</div>
        <div class="stat-value" id="area2">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Bottom-Right</div>
        <div class="stat-value" id="area3">-</div>
      </div>
    </div>
</div>
        <div class="info-text">
      ðŸ’¡ Valitse pala, kierrÃ¤ klikkaamalla ja sijoita laudalle. Tavoite: jokainen neljÃ¤stÃ¤ 3Ã—3-alueesta muodostaa kelvollisen nopan silmÃ¤luvun (1â€“6).
    </div>
    <div class="info-text" id="statusText" style="margin-top:10px;">
      Status: â€“
    </div>
  </div>
</div>

<script>
  // Function to rotate a shape 90 degrees clockwise
  function rotateShape(shape) {
    const minR = Math.min(...shape.map(c => c.r));
    const maxR = Math.max(...shape.map(c => c.r));
    const minC = Math.min(...shape.map(c => c.c));
    const maxC = Math.max(...shape.map(c => c.c));
    
    const h = maxR - minR + 1;
    const w = maxC - minC + 1;
    
    const rotated = shape.map(cell => ({
      r: cell.c - minC,
      c: h - 1 - (cell.r - minR),
      dot: cell.dot
    }));
    
    return rotated;
  }

  // Generate all rotations for a piece
  function generateAllRotations(baseShape) {
    const rotations = [baseShape];
    let current = baseShape;
    for (let i = 0; i < 3; i++) {
      current = rotateShape(current);
      rotations.push(current);
    }
    // Remove duplicate rotations
    return rotations.filter((rot, idx, arr) => 
      idx === 0 || JSON.stringify(rot) !== JSON.stringify(arr[idx - 1])
    );
  }

  // Piece definitions: base shape only
  const PIECE_DEFINITIONS = [
    // oo (0 dots)
    { name: 'oo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:false}]},
    // ox (1 dot)
    { name: 'ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}]},
    // xx (2 dots)
    { name: 'xx', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:true}]},
    // xoo (1 dot)
    { name: 'xoo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}]},
    // xox (2 dots)
    { name: 'xox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:true}]},
    // xoox (2 dots)
    { name: 'xoox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}, {r:0,c:3,dot:true}]},
    // ox/oo 2Ã—2 (1 dot)
    { name: 'ox/oo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}]},
    // xo/ox 2Ã—2 (2 dots)
    { name: 'xo/ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:true}]},
    // oxo/ooo 2Ã—3 (1 dot)
    { name: 'oxo/ooo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:true}, {r:0,c:2,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}, {r:1,c:2,dot:false}]}
  ];

  // Create pieces: 4Ã—oo + others
  let pieces = [];
  let pieceId = 0;
  for (let i = 0; i < 4; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[0].base);
    pieces.push({ 
      id: pieceId++, 
      name: 'oo', 
      rotation: 0, 
      shapes: shapes
    });
  }
  for (let i = 1; i < PIECE_DEFINITIONS.length; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[i].base);
    pieces.push({ 
      id: pieceId++, 
      name: PIECE_DEFINITIONS[i].name, 
      rotation: 0, 
      shapes: shapes
    });
  }

  const board = Array(36).fill(null); // 6Ã—6
  let selectedPiece = null;
  let solved = false;
  let activePuzzle = null; // currently loaded puzzle (for arrow hints)

  const lockedPieceIds = new Set();

  const boardEl = document.getElementById('boardFrame');
  const piecesGridEl = document.getElementById('piecesGrid');
  const resetBtn = document.getElementById('resetBtn');

  const puzzleSelect = document.getElementById('puzzleSelect');
  const statusEl = document.getElementById('statusText');

// --- Dice face validation (3Ã—3 area -> 1..6, rotation independent) ---
const DIE_PATTERNS = (() => {
  // 3Ã—3 coordinates (r,c) with pips
  const base = {
    1: [[1,1]],
    2: [[0,0],[2,2]],
    3: [[0,0],[1,1],[2,2]],
    4: [[0,0],[0,2],[2,0],[2,2]],
    5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
    6: [[0,0],[1,0],[2,0],[0,2],[1,2],[2,2]],
  };

  const rot = (rc) => rc.map(([r,c]) => [c, 2 - r]); // 90Â° CW in 3Ã—3
  const keyOf = (rc) => rc
    .map(([r,c]) => `${r},${c}`)
    .sort()
    .join("|");

  const map = new Map(); // key -> value
  for (const [valStr, coords] of Object.entries(base)) {
    const val = Number(valStr);
    let cur = coords;
    for (let k=0;k<4;k++){
      map.set(keyOf(cur), val);
      cur = rot(cur);
    }
  }
  return map;
})();

function getAreaCells(areaIndex){
  const startRow = (areaIndex < 2) ? 0 : 3;
  const startCol = (areaIndex % 2 === 0) ? 0 : 3;
  const cells = [];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      cells.push(board[(startRow+r)*6 + (startCol+c)]);
    }
  }
  return cells;
}

function getDieValueFromArea(areaIndex){
  const startRow = (areaIndex < 2) ? 0 : 3;
  const startCol = (areaIndex % 2 === 0) ? 0 : 3;

  const dots = [];
  let anyFilled = false;

  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const cell = board[(startRow + r) * 6 + (startCol + c)];
      if (cell !== null) anyFilled = true;
      if (cell && cell.dot) dots.push([r,c]);
    }
  }

  if (!anyFilled) return null; // completely empty area -> show "-"
  const key = dots.map(([r,c]) => `${r},${c}`).sort().join("|");
  return DIE_PATTERNS.get(key) ?? 0; // 0 = invalid
}


function getArrowCheck(type, index, targetSum){
  // Returns: {state:"pending"|"ok"|"bad", currentSum:number|null}
  const TL = getDieValueFromArea(0);
  const TR = getDieValueFromArea(1);
  const BL = getDieValueFromArea(2);
  const BR = getDieValueFromArea(3);

  if (type === "row"){
    const top = index < 3;
    const a = top ? TL : BL;
    const b = top ? TR : BR;
    if (!a || !b) return {state:"pending", currentSum:null}; // null or 0 -> pending/invalid
    const s = a + b;
    return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
  }

  if (type === "column"){
    const left = index < 3;
    const a = left ? TL : TR;
    const b = left ? BL : BR;
    if (!a || !b) return {state:"pending", currentSum:null};
    const s = a + b;
    return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
  }

  return {state:"pending", currentSum:null};
}

function updateStats() {
  for (let i = 0; i < 4; i++) {
    const v = getDieValueFromArea(i);
    let out = "-";
    if (v === 0) out = "Ã—";     // invalid
    else if (v !== null) out = String(v);
    document.getElementById(`area${i}`).textContent = out;
  }
}

function setStatus(msg){
  if (statusEl) statusEl.textContent = `Status: ${msg}`;
}

function checkWin(){
  const allFilled = board.every(x => x !== null);
  const vals = [0,1,2,3].map(getDieValueFromArea);
  const allValid = vals.every(v => v >= 1 && v <= 6);

  if (allFilled && allValid){
    if (!solved){
      solved = true;
      setStatus("âœ… Valmis! (Reset Board aloittaa alusta)");
    }
    return true;
  }
  solved = false;

  if (!allFilled){
    setStatus("Kesken: tÃ¤ytÃ¤ lauta ja muodosta 4 kelvollista noppaa.");
  } else if (!allValid){
    setStatus("Kesken: jokaisen 3Ã—3-alueen pitÃ¤Ã¤ olla kelvollinen noppa (1â€“6).");
  } else {
    setStatus("Kesken.");
  }
  return false;
}

  function getCurrentShape(piece) {
    return piece.shapes[piece.rotation % piece.shapes.length];
  }

  function canPlace(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      if (r < 0 || r >= 6 || c < 0 || c >= 6) return false;
      if (board[r * 6 + c] !== null) return false;
    }
    return true;
  }

  function placePiece(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      const idx = r * 6 + c;
      board[idx] = { pieceId: piece.id, dot: cell.dot };
    }
  }

  function removePiece(piece) {
    for (let i = 0; i < 36; i++) {
      if (board[i] && board[i].pieceId === piece.id) {
        board[i] = null;
      }
    }
  }

  function isPiecePlaced(piece) {
    return board.some(cell => cell && cell.pieceId === piece.id);
  }

  
function renderBoard() {
    boardEl.innerHTML = '';

    // Build quick lookup maps for arrow hints (row/column -> {sum, dir})
    const rowHints = new Map();
    const colHints = new Map();
    if (activePuzzle && Array.isArray(activePuzzle.arrows)) {
      for (const a of activePuzzle.arrows) {
        if (a.type === "row") rowHints.set(a.index, a);
        if (a.type === "column") colHints.set(a.index, a);
      }
    }

    // 7Ã—7 frame: 6Ã—6 cells + extra row/col for hints
    for (let r = 0; r < 7; r++) {
      for (let c = 0; c < 7; c++) {

        // Corner (bottom-right) = empty
        if (r === 6 && c === 6) {
          const h = document.createElement('div');
          h.className = 'hint empty';
          boardEl.appendChild(h);
          continue;
        }

        // Row hints live in the 7th column (c==6), aligned with rows 0..5
        if (c === 6 && r < 6) {
          const h = document.createElement('div');
          const hint = rowHints.get(r);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "left" ? "â† " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("row", r, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        // Column hints live in the 7th row (r==6), aligned with columns 0..5
        if (r === 6 && c < 6) {
          const h = document.createElement('div');
          const hint = colHints.get(c);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "up" ? "â†‘ " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("column", c, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        // Normal board cell (0..5, 0..5)
        const cell = document.createElement('div');
        cell.className = 'cell';

        const bidx = r * 6 + c;
        if (board[bidx]) {
          cell.classList.add('occupied');

          // Piece outline helpers (only for the 6Ã—6 main board)
          const pid = board[bidx].pieceId;
          if (pid !== undefined && pid !== null) {
            cell.classList.add('piece');

            // Determine which edges are on the piece boundary
            const same = (rr, cc) => {
              if (rr < 0 || rr >= 6 || cc < 0 || cc >= 6) return false;
              const n = board[rr * 6 + cc];
              return !!n && n.pieceId === pid;
            };

            // Use CSS variables so multiple edges can be drawn at once
            cell.style.setProperty('--pt', same(r-1, c) ? '0px' : '3px');
            cell.style.setProperty('--pr', same(r, c+1) ? '0px' : '3px');
            cell.style.setProperty('--pb', same(r+1, c) ? '0px' : '3px');
            cell.style.setProperty('--pl', same(r, c-1) ? '0px' : '3px');
          }

          if (board[bidx].dot) cell.textContent = 'â—';
        }

        cell.addEventListener('click', () => placePieceOnBoard(r, c));
        boardEl.appendChild(cell);
      }
    }

    updateStats();
    checkWin();
  }


  function placePieceOnBoard(r, c) {
    const idx = r * 6 + c;
    if (solved) return;
    // If cell is occupied, remove the piece (unless locked)
    if (board[idx] !== null) {
      const pieceId = board[idx].pieceId;
      if (lockedPieceIds.has(pieceId)) return;
      const pieceIdx = pieces.findIndex(p => p.id === pieceId);
      if (pieceIdx !== -1) {
        removePiece(pieces[pieceIdx]);
        renderBoard();
        renderPieces();
      }
      return;
    }

    // Otherwise, place selected piece
    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];

    // Locked pieces (loaded from a puzzle) cannot be moved
    if (lockedPieceIds.has(piece.id) && isPiecePlaced(piece)) return;

    if (canPlace(piece, r, c)) {
      removePiece(piece);
      placePiece(piece, r, c);
      renderBoard();
      renderPieces();
    }
  }

  function renderPieces() {
    piecesGridEl.innerHTML = '';
    pieces.forEach((piece, idx) => {
      const btn = document.createElement('button');
      btn.className = 'piece-btn';
      if (selectedPiece === idx) btn.classList.add('selected');
      if (isPiecePlaced(piece)) btn.classList.add('used');
      
      const shape = getCurrentShape(piece);
      const minR = Math.min(...shape.map(c => c.r));
      const maxR = Math.max(...shape.map(c => c.r));
      const minC = Math.min(...shape.map(c => c.c));
      const maxC = Math.max(...shape.map(c => c.c));
      
      const cols = maxC - minC + 1;
let previewHtml = `<div class="piece-preview" style="--cols:${cols};">`;
      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          const hasCell = shape.some(cell => cell.r === r && cell.c === c);
          const hasDot = shape.some(cell => cell.r === r && cell.c === c && cell.dot);
          if (hasCell) {
            previewHtml += `<div class="piece-preview-cell ${hasDot ? 'dot' : ''}"></div>`;
          } else {
            previewHtml += `<div class="piece-preview-cell empty"></div>`;
          }
        }
      }
      previewHtml += '</div>';
      
      btn.innerHTML = previewHtml + `<div class="piece-info">${piece.name}</div>`;
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (solved) return;

        // Locked pieces (loaded from a puzzle) cannot be selected/rotated/moved
        if (lockedPieceIds.has(piece.id)) return;

        if (selectedPiece === idx) {
          // Second click on same piece: rotate
          rotatePiece();
        } else {
          // First click: select piece
          selectedPiece = idx;
        }
        renderPieces();
      });
      piecesGridEl.appendChild(btn);
    });
  }

  function rotatePiece() {
    if (solved) return;
    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];
    piece.rotation = (piece.rotation + 1) % piece.shapes.length;
    renderPieces();
  }
  // ---- Puzzles loaded from dice_deduction_puzzles.json ----
let PUZZLE_DB = null;

async function loadPuzzleFile() {
  try {
    const res = await fetch("dice_deduction_puzzles.json", { cache: "no-store" });
    if (!res.ok) throw new Error(res.status);
    PUZZLE_DB = await res.json();

    populatePuzzleSelect();

    // lataa oletuspulma
    if (PUZZLE_DB.puzzles?.length) {
      puzzleSelect.value = String(PUZZLE_DB.puzzles[0].id);
      loadPuzzle(PUZZLE_DB.puzzles[0]);
    }

    setStatus(`Loaded ${PUZZLE_DB.puzzles.length} puzzles`);
  } catch (err) {
    console.error("Puzzle load failed", err);
    setStatus("âŒ Puzzle file not loaded");
  }
}

  function puzzleLabel(p) {
    const title = (p.title || "").trim();
    const base = `#${p.id} â€¢ ${p.difficulty || "?"}`;
    return title ? `${base} â€¢ ${title}` : base;
  }
function clearLocked() {
    lockedPieceIds.clear();
  }

  function findUnusedPieceByName(name) {
    const usedIds = new Set(board.filter(x => x).map(x => x.pieceId));
    return pieces.find(p => p.name === name && !usedIds.has(p.id));
  }

  function loadPuzzle(puz) {
    // Clear board + reset piece rotations
    for (let i = 0; i < 36; i++) board[i] = null;
    for (let p of pieces) p.rotation = 0;
    selectedPiece = null;
    solved = false;
    clearLocked();

    activePuzzle = puz;
    // Place locked pieces
    for (const lp of puz.lockedPieces || []) {
      const piece = findUnusedPieceByName(lp.piece);
      if (!piece) {
        console.warn("No unused piece found for", lp.piece);
        continue;
      }
      piece.rotation = lp.rotation || 0;

      if (!canPlace(piece, lp.row, lp.col)) {
        console.warn("Cannot place locked piece", lp, "with current rotation. Skipping.");
        continue;
      }
      placePiece(piece, lp.row, lp.col);
      lockedPieceIds.add(piece.id);
    }

    renderBoard();
    renderPieces();
    setStatus(`Loaded puzzle #${puz.id} (${puz.difficulty}). Locked pieces: ${lockedPieceIds.size}.`);
  }
function resetBoard() {
	    solved = false;
	    selectedPiece = null;

	    // Always clear the board + reset rotations
	    for (let i = 0; i < 36; i++) board[i] = null;
	    for (let piece of pieces) piece.rotation = 0;

	    if (!activePuzzle) {
	      // Free build mode: clear everything (also any stale lock state)
	      clearLocked();
	      setStatus("â€“");
	    } else {
	      // Puzzle mode: keep the puzzle's locked pieces, remove only player pieces
	      clearLocked();
	      for (const lp of activePuzzle.lockedPieces || []) {
	        const piece = findUnusedPieceByName(lp.piece);
	        if (!piece) continue;
	        piece.rotation = lp.rotation || 0;
	        if (canPlace(piece, lp.row, lp.col)) {
	          placePiece(piece, lp.row, lp.col);
	          lockedPieceIds.add(piece.id);
	        }
	      }
	      setStatus(`Reset: puzzle #${activePuzzle.id} (${activePuzzle.difficulty}). Locked pieces restored: ${lockedPieceIds.size}.`);
	    }

	    renderBoard();
	    renderPieces();
	  }
  function populatePuzzleSelect(){
    if(!puzzleSelect) return;
    puzzleSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Valitse pulmaâ€¦";
    puzzleSelect.appendChild(opt0);

    for (const p of (PUZZLE_DB.puzzles || [])){
      const opt = document.createElement("option");
      opt.value = String(p.id);
      opt.textContent = puzzleLabel(p);
      puzzleSelect.appendChild(opt);
    }
  }

  resetBtn.addEventListener('click', resetBoard);


puzzleSelect.addEventListener("change", ()=>{
  if (!PUZZLE_DB) return;
  const id = Number(puzzleSelect.value);
  if(!id) return;
  const puz = PUZZLE_DB.puzzles.find(p => p.id === id);
  if (puz) loadPuzzle(puz);
});


document.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      rotatePiece();
    }
  });
loadPuzzleFile();

  renderBoard();
  renderPieces();
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./service-worker.js").catch(console.error);
    });
  }
</script>

</body>
</html>