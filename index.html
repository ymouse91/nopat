<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Dice Deduction</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#16213e">
  <meta property="og:image" content="https://ymouse91.github.io/nopat/icon-192.png">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="./icon-192.png">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: calc(env(safe-area-inset-top) + 12px) 12px calc(env(safe-area-inset-bottom) + 16px);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container { width: min(900px, 99vw); }

    h1 {
      font-size: 28px;
      font-weight: 800;
      text-align: center;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      align-items: center;
    }

    .controls select{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color: #fff;
      outline: none;
    }
    .controls select option{ color: #000; }

    button {
      padding: 10px 14px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      color: #000;
      transition: transform 0.2s;
    }
    button:active { transform: scale(0.95); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .board-wrapper {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .boardframe {
      display: grid;
      position: relative;

      --gap: 4px;
      --pad: 12px;

      --cell: calc((100% - (var(--pad) * 2) - (var(--gap) * 6)) / 7);

      grid-template-columns: repeat(7, var(--cell));
      grid-template-rows: repeat(7, var(--cell));

      gap: var(--gap);
      background: rgba(0, 0, 0, 0.3);
      padding: var(--pad);
      border-radius: 14px;
      width: min(420px, 95vw);
      aspect-ratio: 1;
    }

    .boardframe::before,
    .boardframe::after{
      content:"";
      position:absolute;
      pointer-events:none;

      --play:  calc((var(--cell) * 6) + (var(--gap) * 5));
      --split: calc((var(--cell) * 3) + (var(--gap) * 2) + (var(--gap) / 2));
      --w: 4px;

      background: rgba(0, 212, 255, 1);
      opacity: 0.85;
      border-radius: 999px;
      --nx: -10px;
      --ny: -11px;
    }

    .boardframe::before{
      left: calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--nx));
      top:  calc(var(--pad) + var(--ny));
      width: var(--w);
      height: var(--play);
    }

    .boardframe::after{
      left: calc(var(--pad) + var(--nx));
      top:  calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--ny));
      width: var(--play);
      height: var(--w);
    }

    .cell {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
      user-select: none;
    }

    .cell:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
    }

    .cell.occupied {
      background: rgba(0, 212, 255, 0.15);
      border-color: rgba(0, 212, 255, 0.4);
    }

    .cell.piece { position: relative; }
    .cell.piece::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-top: var(--pt, 0px) solid rgba(255,255,255,0.75);
      border-right: var(--pr, 0px) solid rgba(255,255,255,0.75);
      border-bottom: var(--pb, 0px) solid rgba(255,255,255,0.75);
      border-left: var(--pl, 0px) solid rgba(255,255,255,0.75);
      border-radius: 6px;
      pointer-events:none;
    }

    .hint {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.06);
      border: 2px dashed rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0.2px;
      user-select: none;
    }
    .hint.empty { background: transparent; border-color: transparent; }

    .hint.ok {
      background: rgba(0, 212, 255, 0.18);
      border-style: solid;
      border-color: rgba(0, 212, 255, 0.6);
    }
    .hint.bad {
      background: rgba(255, 80, 80, 0.18);
      border-style: solid;
      border-color: rgba(255, 80, 80, 0.6);
    }

    .pieces-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px;
      min-width: 300px;
    }

    .pieces-grid{
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .piece-btn {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 0.2s;
      position: relative;
      padding: 4px;
    }

    .piece-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .piece-btn.selected {
      background: rgba(0, 212, 255, 0.3);
      border-color: rgba(0, 212, 255, 0.8);
      box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
    }

    .piece-btn.used {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .piece-preview{
      --pv: 16px;
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--pv));
      grid-auto-rows: var(--pv);
      gap: 2px;
      place-content: center;
    }

    .piece-preview-cell {
      width: 16px;
      height: 16px;
      background: rgba(0, 212, 255, 0.5);
      border-radius: 2px;
    }

    .piece-preview-cell.empty { width: 16px; height: 16px; }

    .piece-preview-cell.dot { position: relative; background: #00d4ff; }
    .piece-preview-cell.dot::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
    }

    .piece-info { font-size: 11px; opacity: 0.7; }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 16px;
      font-size: 13px;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.08);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .stat-label { opacity: 0.7; font-size: 11px; }
    .stat-value { font-size: 18px; font-weight: 800; color: #00d4ff; margin-top: 4px; }

    .info-text { font-size: 13px; opacity: 0.7; margin-top: 12px; line-height: 1.5; }

    @media (min-width: 900px) {
      .board-wrapper{
        flex-wrap: nowrap;
        align-items: flex-start;
        justify-content: center;
        gap: 16px;
      }
      .pieces-grid{ grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .piece-btn{ min-height: 70px; padding: 6px; }
      .piece-preview{ width: 48px; height: 48px; }
    }

    @media (max-width: 520px){
      body{ padding-left: 4px; padding-right: 4px; overflow-x: hidden; }
      .container{ width: 100%; }
      .panel{ padding: 10px; }
      .board-wrapper{
        width: 100%;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      .boardframe{
        width: calc(100vw - 8px);
        max-width: 100%;
        --pad: 6px;
        --gap: 3px;
      }
      .boardframe::before,
      .boardframe::after{
        --nx: -5px;
        --ny: -5px;
      }
      .pieces-panel{
        min-width: 0;
        width: 100%;
        max-width: 100%;
      }
      .pieces-grid{
        width: 100%;
        max-width: 100%;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 4px;
      }
      .piece-btn{
        min-width: 0;
        padding: 2px;
        border-radius: 6px;
      }
      .piece-preview{
        --pv: 7px;
        grid-template-columns: repeat(var(--cols), var(--pv)) !important;
        grid-auto-rows: var(--pv);
        gap: 1px;
        justify-content: start;
        align-content: start;
        max-width: 100%;
      }
      .piece-preview-cell,
      .piece-preview-cell.empty{
        width: var(--pv);
        height: var(--pv);
        margin: 0;
      }
      .piece-preview-cell.dot::after{ width: 3px; height: 3px; }
      .hint{ font-size: 12px; letter-spacing: 0.1px; }
      .piece-info{ display:none; }
      .pieces-panel > div:first-child{ display:none; }

      .controls select{
        padding: 8px 10px;
        border-radius: 4px;
      }
      button {
        padding: 8px 10px;
        border-radius: 5px;
        font-size: 10px;
      }
      h1 { font-size: 20px; margin-bottom: 10px; }
      label span { display: none; }
    }
  </style>
</head>

<body>
<div class="container">
  <h1 id="title">üé≤ Nokkelat nopat</h1>

  <div class="panel">
    <div class="controls">
      <label style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:12px; opacity:.85;">Pulma:</span>
        <select id="puzzleSelect" aria-label="Puzzle selector"></select>
      </label>
      <button id="resetBtn">Nollaa</button>
      <button id="solveBtn">Ratkaisu</button>
    </div>

    <div class="board-wrapper">
      <div class="boardframe" id="boardFrame"></div>

      <div class="pieces-panel">
        <div style="font-size: 14px; font-weight: 700; margin-bottom: 12px;">Palat</div>
        <div class="pieces-grid" id="piecesGrid"></div>
      </div>
    </div>

    <div hidden>
      <div class="stats">
        <div class="stat-box">
          <div class="stat-label">Top-Left</div>
          <div class="stat-value" id="area0">-</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Top-Right</div>
          <div class="stat-value" id="area1">-</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Bottom-Left</div>
          <div class="stat-value" id="area2">-</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Bottom-Right</div>
          <div class="stat-value" id="area3">-</div>
        </div>
      </div>
    </div>

    <div class="info-text">
      üí° Kierr√§ palaa klikkaamalla ja sijoita laudalle. Tavoite: jokainen nelj√§st√§ 3√ó3-alueesta muodostaa kelvollisen nopan silm√§luvun (1‚Äì6).
    </div>
    <div class="info-text" id="statusText" style="margin-top:10px;">
      Status: ‚Äì
    </div>
  </div>
</div>

<script>
  // --- Muista viimeisin valittu pulma ---
  const LAST_PUZZLE_KEY = "diceDeduction_lastPuzzleId";
  function saveLastPuzzleId(id){
    try { localStorage.setItem(LAST_PUZZLE_KEY, String(id)); } catch(_) {}
  }
  function loadLastPuzzleId(){
    try {
      const v = localStorage.getItem(LAST_PUZZLE_KEY);
      const n = Number(v);
      return Number.isFinite(n) && n > 0 ? n : null;
    } catch(_) {
      return null;
    }
  }

  // Function to rotate a shape 90 degrees clockwise
  function rotateShape(shape) {
    const minR = Math.min(...shape.map(c => c.r));
    const maxR = Math.max(...shape.map(c => c.r));
    const minC = Math.min(...shape.map(c => c.c));
    const maxC = Math.max(...shape.map(c => c.c));

    const h = maxR - minR + 1;

    const rotated = shape.map(cell => ({
      r: cell.c - minC,
      c: h - 1 - (cell.r - minR),
      dot: cell.dot
    }));

    return rotated;
  }

  // Generate all rotations for a piece
  function generateAllRotations(baseShape) {
    const rotations = [baseShape];
    let current = baseShape;
    for (let i = 0; i < 3; i++) {
      current = rotateShape(current);
      rotations.push(current);
    }
    // Remove duplicate rotations
    return rotations.filter((rot, idx, arr) =>
      idx === 0 || JSON.stringify(rot) !== JSON.stringify(arr[idx - 1])
    );
  }

  // Piece definitions: base shape only
  const PIECE_DEFINITIONS = [
    { name: 'oo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:false}]},
    { name: 'ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}]},
    { name: 'xx', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:true}]},
    { name: 'xoo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}]},
    { name: 'xox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:true}]},
    { name: 'xoox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}, {r:0,c:3,dot:true}]},
    { name: 'ox/oo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}]},
    { name: 'xo/ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:true}]},
    { name: 'oxo/ooo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:true}, {r:0,c:2,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}, {r:1,c:2,dot:false}]}
  ];

  // Create pieces: 4√óoo + others
  let pieces = [];
  let pieceId = 0;
  for (let i = 0; i < 4; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[0].base);
    pieces.push({
      id: pieceId++,
      name: 'oo',
      rotation: 0,
      shapes: shapes
    });
  }
  for (let i = 1; i < PIECE_DEFINITIONS.length; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[i].base);
    pieces.push({
      id: pieceId++,
      name: PIECE_DEFINITIONS[i].name,
      rotation: 0,
      shapes: shapes
    });
  }

  const board = Array(36).fill(null); // 6√ó6
  let selectedPiece = null;
  let solved = false;
  let activePuzzle = null; // currently loaded puzzle (for arrow hints)

  const lockedPieceIds = new Set();

  const boardEl = document.getElementById('boardFrame');
  const piecesGridEl = document.getElementById('piecesGrid');
  const resetBtn = document.getElementById('resetBtn');
  const solveBtn = document.getElementById('solveBtn');

  const puzzleSelect = document.getElementById('puzzleSelect');
  const statusEl = document.getElementById('statusText');

  // --- Dice face validation (3√ó3 area -> 1..6, rotation independent) ---
  const DIE_PATTERNS = (() => {
    const base = {
      1: [[1,1]],
      2: [[0,0],[2,2]],
      3: [[0,0],[1,1],[2,2]],
      4: [[0,0],[0,2],[2,0],[2,2]],
      5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
      6: [[0,0],[1,0],[2,0],[0,2],[1,2],[2,2]],
    };

    const rot = (rc) => rc.map(([r,c]) => [c, 2 - r]);
    const keyOf = (rc) => rc.map(([r,c]) => `${r},${c}`).sort().join("|");

    const map = new Map();
    for (const [valStr, coords] of Object.entries(base)) {
      const val = Number(valStr);
      let cur = coords;
      for (let k=0;k<4;k++){
        map.set(keyOf(cur), val);
        cur = rot(cur);
      }
    }
    return map;
  })();

  function getAreaCells(areaIndex){
    const startRow = (areaIndex < 2) ? 0 : 3;
    const startCol = (areaIndex % 2 === 0) ? 0 : 3;
    const cells = [];
    for(let r=0;r<3;r++){
      for(let c=0;c<3;c++){
        cells.push(board[(startRow+r)*6 + (startCol+c)]);
      }
    }
    return cells;
  }

  function getDieValueFromArea(areaIndex){
    const startRow = (areaIndex < 2) ? 0 : 3;
    const startCol = (areaIndex % 2 === 0) ? 0 : 3;

    const dots = [];
    let anyFilled = false;

    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        const cell = board[(startRow + r) * 6 + (startCol + c)];
        if (cell !== null) anyFilled = true;
        if (cell && cell.dot) dots.push([r,c]);
      }
    }

    if (!anyFilled) return null;
    const key = dots.map(([r,c]) => `${r},${c}`).sort().join("|");
    return DIE_PATTERNS.get(key) ?? 0;
  }

  function getArrowCheck(type, index, targetSum){
    const TL = getDieValueFromArea(0);
    const TR = getDieValueFromArea(1);
    const BL = getDieValueFromArea(2);
    const BR = getDieValueFromArea(3);

    if (type === "row"){
      const top = index < 3;
      const a = top ? TL : BL;
      const b = top ? TR : BR;
      if (!a || !b) return {state:"pending", currentSum:null};
      const s = a + b;
      return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
    }

    if (type === "column"){
      const left = index < 3;
      const a = left ? TL : TR;
      const b = left ? BL : BR;
      if (!a || !b) return {state:"pending", currentSum:null};
      const s = a + b;
      return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
    }

    return {state:"pending", currentSum:null};
  }

  function updateStats() {
    for (let i = 0; i < 4; i++) {
      const v = getDieValueFromArea(i);
      let out = "-";
      if (v === 0) out = "√ó";
      else if (v !== null) out = String(v);
      document.getElementById(`area${i}`).textContent = out;
    }
  }

  function setStatus(msg){
    if (statusEl) statusEl.textContent = `Status: ${msg}`;
  }

  function checkWin(){
    const allFilled = board.every(x => x !== null);
    const vals = [0,1,2,3].map(getDieValueFromArea);
    const allValid = vals.every(v => v >= 1 && v <= 6);

    if (allFilled && allValid){
      if (!solved){
        solved = true;
        setStatus("‚úÖ Valmis! (Reset Board aloittaa alusta)");
      }
      return true;
    }
    solved = false;

    if (!allFilled){
      setStatus("Kesken: t√§yt√§ lauta ja muodosta 4 kelvollista noppaa.");
    } else if (!allValid){
      setStatus("Kesken: jokaisen 3√ó3-alueen pit√§√§ olla kelvollinen noppa (1‚Äì6).");
    } else {
      setStatus("Kesken.");
    }
    return false;
  }

  function getCurrentShape(piece) {
    return piece.shapes[piece.rotation % piece.shapes.length];
  }

  function canPlace(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      if (r < 0 || r >= 6 || c < 0 || c >= 6) return false;
      if (board[r * 6 + c] !== null) return false;
    }
    return true;
  }

  function placePiece(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      const idx = r * 6 + c;
      board[idx] = { pieceId: piece.id, dot: cell.dot };
    }
  }

  function removePiece(piece) {
    for (let i = 0; i < 36; i++) {
      if (board[i] && board[i].pieceId === piece.id) {
        board[i] = null;
      }
    }
  }

  function isPiecePlaced(piece) {
    return board.some(cell => cell && cell.pieceId === piece.id);
  }

  function renderBoard() {
    boardEl.innerHTML = '';

    const rowHints = new Map();
    const colHints = new Map();
    if (activePuzzle && Array.isArray(activePuzzle.arrows)) {
      for (const a of activePuzzle.arrows) {
        if (a.type === "row") rowHints.set(a.index, a);
        if (a.type === "column") colHints.set(a.index, a);
      }
    }

    for (let r = 0; r < 7; r++) {
      for (let c = 0; c < 7; c++) {

        if (r === 6 && c === 6) {
          const h = document.createElement('div');
          h.className = 'hint empty';
          boardEl.appendChild(h);
          continue;
        }

        if (c === 6 && r < 6) {
          const h = document.createElement('div');
          const hint = rowHints.get(r);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "left" ? "‚Üê " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("row", r, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        if (r === 6 && c < 6) {
          const h = document.createElement('div');
          const hint = colHints.get(c);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "up" ? "‚Üë " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("column", c, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        const cell = document.createElement('div');
        cell.className = 'cell';

        const bidx = r * 6 + c;
        if (board[bidx]) {
          cell.classList.add('occupied');

          const pid = board[bidx].pieceId;
          if (pid !== undefined && pid !== null) {
            cell.classList.add('piece');

            const same = (rr, cc) => {
              if (rr < 0 || rr >= 6 || cc < 0 || cc >= 6) return false;
              const n = board[rr * 6 + cc];
              return !!n && n.pieceId === pid;
            };

            cell.style.setProperty('--pt', same(r-1, c) ? '0px' : '3px');
            cell.style.setProperty('--pr', same(r, c+1) ? '0px' : '3px');
            cell.style.setProperty('--pb', same(r+1, c) ? '0px' : '3px');
            cell.style.setProperty('--pl', same(r, c-1) ? '0px' : '3px');
          }

          if (board[bidx].dot) cell.textContent = '‚óè';
        }

        cell.addEventListener('click', () => placePieceOnBoard(r, c));
        boardEl.appendChild(cell);
      }
    }

    updateStats();
    checkWin();
  }

  function placePieceOnBoard(r, c) {
    const idx = r * 6 + c;
    if (solved) return;

    if (board[idx] !== null) {
      const pieceId = board[idx].pieceId;
      if (lockedPieceIds.has(pieceId)) return;
      const pieceIdx = pieces.findIndex(p => p.id === pieceId);
      if (pieceIdx !== -1) {
        removePiece(pieces[pieceIdx]);
        renderBoard();
        renderPieces();
      }
      return;
    }

    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];

    if (lockedPieceIds.has(piece.id) && isPiecePlaced(piece)) return;

    if (canPlace(piece, r, c)) {
      removePiece(piece);
      placePiece(piece, r, c);
      renderBoard();
      renderPieces();
    }
  }

  function renderPieces() {
    piecesGridEl.innerHTML = '';
    pieces.forEach((piece, idx) => {
      const btn = document.createElement('button');
      btn.className = 'piece-btn';
      if (selectedPiece === idx) btn.classList.add('selected');
      if (isPiecePlaced(piece)) btn.classList.add('used');

      const shape = getCurrentShape(piece);
      const minR = Math.min(...shape.map(c => c.r));
      const maxR = Math.max(...shape.map(c => c.r));
      const minC = Math.min(...shape.map(c => c.c));
      const maxC = Math.max(...shape.map(c => c.c));

      const cols = maxC - minC + 1;
      let previewHtml = `<div class="piece-preview" style="--cols:${cols};">`;
      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          const hasCell = shape.some(cell => cell.r === r && cell.c === c);
          const hasDot = shape.some(cell => cell.r === r && cell.c === c && cell.dot);
          if (hasCell) previewHtml += `<div class="piece-preview-cell ${hasDot ? 'dot' : ''}"></div>`;
          else previewHtml += `<div class="piece-preview-cell empty"></div>`;
        }
      }
      previewHtml += '</div>';

      btn.innerHTML = previewHtml + `<div class="piece-info">${piece.name}</div>`;
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (solved) return;
        if (lockedPieceIds.has(piece.id)) return;

        if (selectedPiece === idx) rotatePiece();
        else selectedPiece = idx;

        renderPieces();
      });
      piecesGridEl.appendChild(btn);
    });
  }

  function rotatePiece() {
    if (solved) return;
    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];
    piece.rotation = (piece.rotation + 1) % piece.shapes.length;
    renderPieces();
  }

  // ---- Puzzles loaded from dice_deduction_puzzles.json ----
  let PUZZLE_DB = null;

  async function loadPuzzleFile() {
    try {
      const res = await fetch("dice_deduction_puzzles.json", { cache: "no-store" });
      if (!res.ok) throw new Error(res.status);
      PUZZLE_DB = await res.json();

      populatePuzzleSelect();

      // --- Lataa viimeisin valittu pulma, jos l√∂ytyy; muuten 1. ---
      const savedId = loadLastPuzzleId();
      let chosen = null;

      if (savedId && PUZZLE_DB.puzzles?.length) {
        chosen = PUZZLE_DB.puzzles.find(p => p.id === savedId) || null;
      }
      if (!chosen && PUZZLE_DB.puzzles?.length) {
        chosen = PUZZLE_DB.puzzles[0];
      }

      if (chosen) {
        puzzleSelect.value = String(chosen.id);
        loadPuzzle(chosen);
      }

      setStatus(`Loaded ${PUZZLE_DB.puzzles.length} puzzles`);
    } catch (err) {
      console.error("Puzzle load failed", err);
      setStatus("‚ùå Puzzle file not loaded");
    }
  }

  function puzzleLabel(p) {
    const title = (p.title || "").trim();
    const base = `#${p.id} ‚Ä¢ ${p.difficulty || "?"}`;
    return title ? `${base} ‚Ä¢ ${title}` : base;
  }

  function clearLocked() {
    lockedPieceIds.clear();
  }

  function findUnusedPieceByName(name) {
    const usedIds = new Set(board.filter(x => x).map(x => x.pieceId));
    return pieces.find(p => p.name === name && !usedIds.has(p.id));
  }

  function loadPuzzle(puz) {
    // muista valinta
    if (puz && puz.id) saveLastPuzzleId(puz.id);

    for (let i = 0; i < 36; i++) board[i] = null;
    for (let p of pieces) p.rotation = 0;
    selectedPiece = null;
    solved = false;
    clearLocked();

    activePuzzle = puz;

    for (const lp of puz.lockedPieces || []) {
      const piece = findUnusedPieceByName(lp.piece);
      if (!piece) {
        console.warn("No unused piece found for", lp.piece);
        continue;
      }
      piece.rotation = lp.rotation || 0;

      if (!canPlace(piece, lp.row, lp.col)) {
        console.warn("Cannot place locked piece", lp, "with current rotation. Skipping.");
        continue;
      }
      placePiece(piece, lp.row, lp.col);
      lockedPieceIds.add(piece.id);
    }

    renderBoard();
    renderPieces();
    setStatus(`Loaded puzzle #${puz.id} (${puz.difficulty}). Locked pieces: ${lockedPieceIds.size}.`);
  }

  function resetBoard() {
    solved = false;
    selectedPiece = null;

    for (let i = 0; i < 36; i++) board[i] = null;
    for (let piece of pieces) piece.rotation = 0;

    if (!activePuzzle) {
      clearLocked();
      setStatus("‚Äì");
    } else {
      clearLocked();
      for (const lp of activePuzzle.lockedPieces || []) {
        const piece = findUnusedPieceByName(lp.piece);
        if (!piece) continue;
        piece.rotation = lp.rotation || 0;
        if (canPlace(piece, lp.row, lp.col)) {
          placePiece(piece, lp.row, lp.col);
          lockedPieceIds.add(piece.id);
        }
      }
      setStatus(`Reset: puzzle #${activePuzzle.id} (${activePuzzle.difficulty}). Locked pieces restored: ${lockedPieceIds.size}.`);
    }

    renderBoard();
    renderPieces();
  }

  /* -------------------- SOLVER (Ratkaise) -------------------- */
  function buildDiePatternSets(){
    const patternsByValue = {1:[],2:[],3:[],4:[],5:[],6:[]};
    for (const [key, val] of DIE_PATTERNS.entries()){
      const s = new Set(key ? key.split("|") : []);
      patternsByValue[val].push(s);
    }
    for (const v of [1,2,3,4,5,6]){
      const seen = new Set();
      patternsByValue[v] = patternsByValue[v].filter(s=>{
        const k = [...s].sort().join("|");
        if(seen.has(k)) return false;
        seen.add(k);
        return true;
      });
    }
    return patternsByValue;
  }
  const DIE_PATTERN_SETS = buildDiePatternSets();

  function getAreaInfoFromBoard(b, areaIndex){
    const startRow = (areaIndex < 2) ? 0 : 3;
    const startCol = (areaIndex % 2 === 0) ? 0 : 3;

    let anyFilled = false;
    let allFilled = true;
    const dots = [];
    const empties = [];

    for(let rr=0; rr<3; rr++){
      for(let cc=0; cc<3; cc++){
        const cell = b[(startRow+rr)*6 + (startCol+cc)];
        if(cell !== null) anyFilled = true;
        else allFilled = false;

        if(cell){
          if(cell.dot) dots.push(`${rr},${cc}`);
          else empties.push(`${rr},${cc}`);
        }
      }
    }

    const dotSet = new Set(dots);
    const emptySet = new Set(empties);
    return { anyFilled, allFilled, dotSet, emptySet };
  }

  function getDieValueFromBoard(b, areaIndex){
    const info = getAreaInfoFromBoard(b, areaIndex);
    if(!info.allFilled) return null;
    const key = [...info.dotSet].sort().join("|");
    return DIE_PATTERNS.get(key) ?? 0;
  }

  function arrowsSatisfiedIfDetermined_original(b){
    if(!activePuzzle || !Array.isArray(activePuzzle.arrows)) return true;

    const areaFilled = [0,1,2,3].map(i => getAreaInfoFromBoard(b,i).allFilled);
    const areaVal    = [0,1,2,3].map(i => getDieValueFromBoard(b,i));

    for(const a of activePuzzle.arrows){
      if(a.type === "row"){
        const top = a.index < 3;
        const ai = top ? 0 : 2;
        const bi = top ? 1 : 3;
        if(areaFilled[ai] && areaFilled[bi]){
          const va = areaVal[ai], vb = areaVal[bi];
          if(!(va>=1 && va<=6 && vb>=1 && vb<=6)) return false;
          if(va + vb !== a.sum) return false;
        }
      } else if(a.type === "column"){
        const left = a.index < 3;
        const ai = left ? 0 : 1;
        const bi = left ? 2 : 3;
        if(areaFilled[ai] && areaFilled[bi]){
          const va = areaVal[ai], vb = areaVal[bi];
          if(!(va>=1 && va<=6 && vb>=1 && vb<=6)) return false;
          if(va + vb !== a.sum) return false;
        }
      }
    }
    return true;
  }

  function arrowsSatisfiedIfDetermined(b){
    return arrowsSatisfiedIfDetermined_original(b);
  }

  function collectPairSums(){
    const out = {topRowSum:null, bottomRowSum:null, leftColSum:null, rightColSum:null};
    if(!activePuzzle || !Array.isArray(activePuzzle.arrows)) return out;

    for(const a of activePuzzle.arrows){
      if(a.type === "row"){
        const key = (a.index < 3) ? "topRowSum" : "bottomRowSum";
        if(out[key] == null) out[key] = a.sum;
        else if(out[key] !== a.sum) return { ...out, _inconsistent:true };
      } else if(a.type === "column"){
        const key = (a.index < 3) ? "leftColSum" : "rightColSum";
        if(out[key] == null) out[key] = a.sum;
        else if(out[key] !== a.sum) return { ...out, _inconsistent:true };
      }
    }
    return out;
  }

  function areaPossibleMaskFromAreaInfo(info){
    if(!info.anyFilled){
      return 0b111111;
    }

    let mask = 0;
    for(const v of [1,2,3,4,5,6]){
      const patterns = DIE_PATTERN_SETS[v];
      let ok = false;

      for(const pat of patterns){
        let good = true;
        for(const d of info.dotSet){
          if(!pat.has(d)){ good = false; break; }
        }
        if(!good) continue;

        for(const e of info.emptySet){
          if(pat.has(e)){ good = false; break; }
        }
        if(good){ ok = true; break; }
      }

      if(ok) mask |= (1 << (v-1));
    }
    return mask;
  }

  function pairSumFeasible(maskA, maskB, target){
    for(let va=1; va<=6; va++){
      if(!(maskA & (1<<(va-1)))) continue;
      const vb = target - va;
      if(vb>=1 && vb<=6 && (maskB & (1<<(vb-1)))) return true;
    }
    return false;
  }

  function totalSum12Feasible(m0,m1,m2,m3){
    for(let a=1;a<=6;a++){
      if(!(m0 & (1<<(a-1)))) continue;
      for(let b=1;b<=6;b++){
        if(!(m1 & (1<<(b-1)))) continue;
        const ab = a+b;
        if(ab > 12) continue;
        for(let c=1;c<=6;c++){
          if(!(m2 & (1<<(c-1)))) continue;
          const abc = ab+c;
          if(abc > 12) continue;
          const d = 12 - abc;
          if(d>=1 && d<=6 && (m3 & (1<<(d-1)))) return true;
        }
      }
    }
    return false;
  }

  function boardConsistent(b){
    const areaInfo = [0,1,2,3].map(i => getAreaInfoFromBoard(b,i));
    const areaMasks = [0,1,2,3].map(i => areaPossibleMaskFromAreaInfo(areaInfo[i]));

    for(const m of areaMasks){
      if(m === 0) return false;
    }

    for(let i=0;i<4;i++){
      if(areaInfo[i].allFilled){
        const v = getDieValueFromBoard(b,i);
        if(!(v>=1 && v<=6)) return false;
        if(!(areaMasks[i] & (1<<(v-1)))) return false;
        areaMasks[i] = (1<<(v-1));
      }
    }

    const sums = collectPairSums();
    if(sums._inconsistent) return false;

    const topSum    = (sums.topRowSum    != null) ? sums.topRowSum    : (sums.bottomRowSum != null ? (12 - sums.bottomRowSum) : null);
    const bottomSum = (sums.bottomRowSum != null) ? sums.bottomRowSum : (sums.topRowSum    != null ? (12 - sums.topRowSum)    : null);
    const leftSum   = (sums.leftColSum   != null) ? sums.leftColSum   : (sums.rightColSum  != null ? (12 - sums.rightColSum)  : null);
    const rightSum  = (sums.rightColSum  != null) ? sums.rightColSum  : (sums.leftColSum   != null ? (12 - sums.leftColSum)   : null);

    if(topSum != null && !pairSumFeasible(areaMasks[0], areaMasks[1], topSum)) return false;
    if(bottomSum != null && !pairSumFeasible(areaMasks[2], areaMasks[3], bottomSum)) return false;
    if(leftSum != null && !pairSumFeasible(areaMasks[0], areaMasks[2], leftSum)) return false;
    if(rightSum != null && !pairSumFeasible(areaMasks[1], areaMasks[3], rightSum)) return false;

    if(!totalSum12Feasible(areaMasks[0], areaMasks[1], areaMasks[2], areaMasks[3])) return false;

    if(!arrowsSatisfiedIfDetermined_original(b)) return false;

    return true;
  }

  function canPlaceOn(b, piece, startRow, startCol, rotIndex){
    const shape = piece.shapes[rotIndex % piece.shapes.length];
    for(const cell of shape){
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      if(r<0 || r>=6 || c<0 || c>=6) return false;
      if(b[r*6+c] !== null) return false;
    }
    return true;
  }

  function placePieceOn(b, piece, startRow, startCol, rotIndex){
    const shape = piece.shapes[rotIndex % piece.shapes.length];
    for(const cell of shape){
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      b[r*6+c] = { pieceId: piece.id, dot: cell.dot };
    }
  }

  function cloneBoard(b){
    return b.map(x => x ? {pieceId:x.pieceId, dot:x.dot} : null);
  }

  function getPlacementsForPiece(b, piece){
    const placements = [];
    for(let rot=0; rot<piece.shapes.length; rot++){
      const shape = piece.shapes[rot];
      const maxR = Math.max(...shape.map(c=>c.r));
      const maxC = Math.max(...shape.map(c=>c.c));
      for(let r=0; r<=6-(maxR+1); r++){
        for(let c=0; c<=6-(maxC+1); c++){
          if(canPlaceOn(b, piece, r, c, rot)){
            placements.push({r,c,rot});
          }
        }
      }
    }
    return placements;
  }

  function pickNextPiece(b, remainingPieces){
    let bestIdx = -1;
    let bestPlacements = null;

    for(let i=0;i<remainingPieces.length;i++){
      const p = remainingPieces[i];
      const pl = getPlacementsForPiece(b, p);
      if(pl.length === 0) return { idx:i, placements:[] };
      if(bestIdx === -1 || pl.length < bestPlacements.length){
        bestIdx = i;
        bestPlacements = pl;
        if(pl.length === 1) break;
      }
    }
    return { idx: bestIdx, placements: bestPlacements || [] };
  }

  function solveBacktrack(b, remainingPieces){
    if(!boardConsistent(b)) return null;

    if(remainingPieces.length === 0){
      for(let i=0;i<4;i++){
        const v = getDieValueFromBoard(b,i);
        if(!(v>=1 && v<=6)) return null;
        const info = getAreaInfoFromBoard(b,i);
        if(!info.allFilled) return null;
      }
      if(!arrowsSatisfiedIfDetermined(b)) return null;
      return b;
    }

    const pick = pickNextPiece(b, remainingPieces);
    if(pick.idx < 0 || pick.placements.length === 0) return null;

    const piece = remainingPieces[pick.idx];
    const rest = remainingPieces.slice(0, pick.idx).concat(remainingPieces.slice(pick.idx+1));

    const scoreTouch = (pl)=>{
      let s = 0;
      const shape = piece.shapes[pl.rot];
      for(const cell of shape){
        const r = pl.r + cell.r, c = pl.c + cell.c;
        const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
        for(const [rr,cc] of neigh){
          if(rr<0||rr>=6||cc<0||cc>=6) continue;
          if(b[rr*6+cc] !== null) s++;
        }
      }
      return -s;
    };
    pick.placements.sort((a,b2)=> scoreTouch(a)-scoreTouch(b2));

    for(const pl of pick.placements){
      const nb = cloneBoard(b);
      placePieceOn(nb, piece, pl.r, pl.c, pl.rot);

      const solvedB = solveBacktrack(nb, rest);
      if(solvedB) return solvedB;
    }
    return null;
  }

  function solveCurrentPuzzle(){
    if(!activePuzzle){
      alert("Valitse ensin pulma.");
      return;
    }

    resetBoard();

    const startBoard = cloneBoard(board);
    const locked = new Set(lockedPieceIds);
    const remaining = pieces.filter(p => !locked.has(p.id));

    setStatus("‚è≥ Ratkaistaan‚Ä¶");

    setTimeout(()=>{
      const result = solveBacktrack(startBoard, remaining);

      if(!result){
        setStatus("‚ùå Ratkaisua ei l√∂ytynyt (tarkista pulman tiedot).");
        return;
      }

      for(let i=0;i<36;i++){
        board[i] = result[i] ? { pieceId: result[i].pieceId, dot: result[i].dot } : null;
      }

      solved = true;
      selectedPiece = null;

      renderBoard();
      renderPieces();

      setStatus("‚úÖ Ratkaisu n√§ytetty. (Nollaa aloittaa alusta)");
    }, 0);
  }

  function populatePuzzleSelect(){
    if(!puzzleSelect) return;
    puzzleSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Valitse pulma‚Ä¶";
    puzzleSelect.appendChild(opt0);

    for (const p of (PUZZLE_DB.puzzles || [])){
      const opt = document.createElement("option");
      opt.value = String(p.id);
      opt.textContent = puzzleLabel(p);
      puzzleSelect.appendChild(opt);
    }
  }

  resetBtn.addEventListener('click', resetBoard);
  solveBtn.addEventListener('click', (e)=>{ e.preventDefault(); solveCurrentPuzzle(); });

  puzzleSelect.addEventListener("change", ()=>{
    if (!PUZZLE_DB) return;
    const id = Number(puzzleSelect.value);
    if(!id) return;
    const puz = PUZZLE_DB.puzzles.find(p => p.id === id);
    if (puz) loadPuzzle(puz);
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      rotatePiece();
    }
  });

  loadPuzzleFile();

  renderBoard();
  renderPieces();
</script>

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./service-worker.js").catch(console.error);
    });
  }
</script>
<!-- QR Koodi yms‚Ä¶ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

<style>
  #qrOverlay{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.6);z-index:999;
  }
  #qrBox{
    background:#fff;padding:16px 20px;border-radius:12px;text-align:center;
    box-shadow:0 0 20px rgba(0,0,0,.4);
  }
  #qrBox canvas{width:180px;height:180px;}
</style>

<div id="qrOverlay">
  <div id="qrBox">
    <canvas id="qr"></canvas>
    <p style="color:#000;">ymouse91.github.io/nopat/</p>
  </div>
</div>

<script>
const qr=new QRious({
  element:document.getElementById('qr'),
  value:'https://ymouse91.github.io/nopat/',
  size:180
});
const overlay=document.getElementById('qrOverlay');
document.getElementById('title').onclick=()=>overlay.style.display='flex';
overlay.onclick=()=>overlay.style.display='none';
</script>
</body>
</html>
