<!doctype html>
<html lang="fi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Dice Deduction</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#16213e">
  <meta property="og:image" content="https://ymouse91.github.io/nopat/icon-192.png">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="./icon-192.png">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: calc(env(safe-area-inset-top) + 12px) 12px calc(env(safe-area-inset-bottom) + 16px);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      width: min(900px, 99vw);
    }

    h1 {
      font-size: 28px;
      font-weight: 800;
      text-align: center;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      align-items: center;
    }

    
    .controls select{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color: #fff;
      outline: none;
    }
    .controls select option{ color: #000; }
    button {
      padding: 10px 14px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      font-size: 14px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      color: #000;
      transition: transform 0.2s;
    }

    button:active {
      transform: scale(0.95);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .board-wrapper {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
	
.boardframe {
  display: grid;
  position: relative;

  --gap: 4px;
  --pad: 12px;

  /* YHTEINEN solukoko: sama arvo gridille ja ristin laskennalle */
  --cell: calc((100% - (var(--pad) * 2) - (var(--gap) * 6)) / 7);

  /* √ÑL√Ñ k√§yt√§ 1fr ‚Üí fr-py√∂ristys siirt√§√§ risti√§ joillain leveyksill√§ */
  grid-template-columns: repeat(7, var(--cell));
  grid-template-rows: repeat(7, var(--cell));

  gap: var(--gap);
  background: rgba(0, 0, 0, 0.3);
  padding: var(--pad);
  border-radius: 14px;
  width: min(420px, 95vw);
  aspect-ratio: 1;
}

/* Clear cross to separate the four 3√ó3 dice areas INSIDE the 6√ó6 play area.
   NOTE: The board is a 7√ó7 grid (last row/col are hint cells). The cross must NOT extend
   into the hint row/col, so we draw two absolute lines sized to the 6√ó6 area only. */
.boardframe::before,
.boardframe::after{
  content:"";
  position:absolute;
  pointer-events:none;

  /* k√§yt√§ samaa --cell:ia joka on .boardframe:ss√§ */
  --play:  calc((var(--cell) * 6) + (var(--gap) * 5));
  /* sama kuin 3*cell + 2.5*gap, mutta vakaampi laskenta */
  --split: calc((var(--cell) * 3) + (var(--gap) * 2) + (var(--gap) / 2));
  --w: 4px;

  background: rgba(0, 212, 255, 1);
  opacity: 0.85;
  border-radius: 999px;
  --nx: -10px;   /* hienos√§√§t√∂ X (kokeile 0px, 1px, 2px) */
  --ny: -11px;   /* hienos√§√§t√∂ Y */

}

/* vertical line (between columns 2 and 3 of the 6√ó6 play area) */
.boardframe::before{
  left: calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--nx));
  top:  calc(var(--pad) + var(--ny));
  width: var(--w);
  height: var(--play);
}

.boardframe::after{
  left: calc(var(--pad) + var(--nx));
  top:  calc(var(--pad) + var(--split) - (var(--w) / 2) + var(--ny));
  width: var(--play);
  height: var(--w);
}


/* Visual divider between the four 3√ó3 dice areas */
.cell {
  aspect-ratio: 1;
  background: rgba(255, 255, 255, 0.08);
  border: 2px solid rgba(255, 255, 255, 0.15);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  position: relative;
  transition: all 0.2s;
  user-select: none;
}


    .cell:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.25);
    }

    .cell.occupied {
      background: rgba(0, 212, 255, 0.15);
      border-color: rgba(0, 212, 255, 0.4);
    }

    
    
    /* Piece outline: draw border only on edges where neighboring cell is not same piece */
    .cell.piece { position: relative; }
    .cell.piece::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-top: var(--pt, 0px) solid rgba(255,255,255,0.75);
      border-right: var(--pr, 0px) solid rgba(255,255,255,0.75);
      border-bottom: var(--pb, 0px) solid rgba(255,255,255,0.75);
      border-left: var(--pl, 0px) solid rgba(255,255,255,0.75);
      border-radius: 6px;
      pointer-events:none;
    }
.hint {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.06);
      border: 2px dashed rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 0.2px;
      user-select: none;
    }
    .hint.empty {
      background: transparent;
      border-color: transparent;
    }

    .hint.ok {
      background: rgba(0, 212, 255, 0.18);
      border-style: solid;
      border-color: rgba(0, 212, 255, 0.6);
    }
    .hint.bad {
      background: rgba(255, 80, 80, 0.18);
      border-style: solid;
      border-color: rgba(255, 80, 80, 0.6);
    }
    .pieces-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px;
	  min-width: 300px;
    }

.pieces-grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* AINA 3 saraketta */
  gap: 8px;
}


    .piece-btn {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 0.2s;
      position: relative;
      padding: 4px;
    }

    .piece-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .piece-btn.selected {
      background: rgba(0, 212, 255, 0.3);
      border-color: rgba(0, 212, 255, 0.8);
      box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
    }

    .piece-btn.used {
      opacity: 0.3;
      cursor: not-allowed;
    }

.piece-preview{
  --pv: 16px; /* PC + iPad oletus */
  display: grid;
  grid-template-columns: repeat(var(--cols), var(--pv));
  grid-auto-rows: var(--pv);
  gap: 2px;
   place-content: center; /* = align-content + justify-content */
}


    .piece-preview-cell {
      width: 16px;
      height: 16px;
      background: rgba(0, 212, 255, 0.5);
      border-radius: 2px;
    }

    .piece-preview-cell.empty {
      width: 16px;
      height: 16px;
    }

.piece-preview-cell.dot {
  position: relative;          /* pakollinen */
  background: #00d4ff;
}

.piece-preview-cell.dot::after {
  content: "";
  position: absolute;

  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  width: 6px;
  height: 6px;

  background: #000;
  border-radius: 50%;
}




    .piece-info {
      font-size: 11px;
      opacity: 0.7;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 16px;
      font-size: 13px;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.08);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .stat-label {
      opacity: 0.7;
      font-size: 11px;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 800;
      color: #00d4ff;
      margin-top: 4px;
    }

    .info-text {
      font-size: 13px;
      opacity: 0.7;
      margin-top: 12px;
      line-height: 1.5;
    }
	
	
	
	/* iPad / tablet: palat oikealle, 3√ó4 ruudukko */
@media (min-width: 900px) {
  .board-wrapper{
    flex-wrap: nowrap;
    align-items: flex-start;
    justify-content: center;
    gap: 16px;
  }



  .pieces-grid{
    grid-template-columns: repeat(3, 1fr); /* 3 pysty-saraketta */
    gap: 8px;
  }

  .piece-btn{
    min-height: 70px;             /* sopiva iPadille */
    padding: 6px;
  }

  .piece-preview{
    width: 48px;
    height: 48px;
  }
}

@media (max-width: 520px){

  /* tiukempi sivureuna */
  body{
    padding-left: 4px;
    padding-right: 4px;
    overflow-x: hidden; /* varmistus */
  }

  .container{
    width: 100%;
  }

  .panel{
    padding: 10px;
  }

  /* palat alle + wrapper ei saa olla kapeampi kuin n√§kym√§ */
  .board-wrapper{
    width: 100%;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  /* T√ÑRKE√Ñ: lauta ei saa nojata vw-laskuihin mobiilissa */
  .boardframe{
    width: calc(100vw - 8px);
    max-width: 100%;
    --pad: 6px;   /* oli 12px */
    --gap: 3px;   /* oli 4px */
  }

  .boardframe::before,
  .boardframe::after{
    --nx: -5px;
    --ny: -5px;
  }
  /* est√§ pieces-panelia venytt√§m√§st√§ leveytt√§ */
  .pieces-panel{
    min-width: 0;      /* kumoaa 240px mobiilissa */
    width: 100%;
    max-width: 100%;
  }

  /* 6 saraketta -> 2 rivi√§, minmax est√§√§ valumisen */
  .pieces-grid{
    width: 100%;
    max-width: 100%;
    grid-template-columns: repeat(6, minmax(0, 1fr));
    gap: 4px;
  }

  /* grid-itemit saa kutistua */
  .piece-btn{
    min-width: 0;
    padding: 2px;
    border-radius: 6px;
  }

  /* miniatyyrit pieneksi */
  .piece-preview{
    --pv: 7px;
    grid-template-columns: repeat(var(--cols), var(--pv)) !important; /* ohittaa inline 16px */
    grid-auto-rows: var(--pv);
    gap: 1px;
    justify-content: start;
    align-content: start;
    max-width: 100%;
  }

  .piece-preview-cell,
  .piece-preview-cell.empty{
    width: var(--pv);
    height: var(--pv);
    margin: 0;
  }

  .piece-preview-cell.dot::after{
    width: 3px;
    height: 3px;
  }

  .hint{
    font-size: 12px;
    letter-spacing: 0.1px;
  }

  /* xo/ox pois + otsikko pois */
  .piece-info{ display:none; }
  .pieces-panel > div:first-child{ display:none; }
  
      .controls select{
      padding: 8px 10px;
      border-radius: 4px;

    }

    button {
      padding: 8px 10px;
      border: none;
      border-radius: 5px;
      font-weight: 700;
      font-size: 10px;

    }
	    h1 {
      font-size: 20px;
      margin-bottom: 10px;
    }
	
	  label span {
    display: none;
  }

}



  </style>
</head>

<body>
<div class="container">
  <h1>üé≤ Nokkelat nopat</h1>
  
  <div class="panel">
    <div class="controls">



      <label style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:12px; opacity:.85;">Pulma:</span>
        <select id="puzzleSelect" aria-label="Puzzle selector"></select>
      </label>
	        <button id="resetBtn">Nollaa</button>
        <button id="solveBtn">Ratkaisu</button>
    </div>

<div class="board-wrapper">
  <div class="boardframe" id="boardFrame"></div>

  <div class="pieces-panel">
    <div style="font-size: 14px; font-weight: 700; margin-bottom: 12px;">Palat</div>
    <div class="pieces-grid" id="piecesGrid"></div>
  </div>
</div>

	
<div hidden>
    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Top-Left</div>
        <div class="stat-value" id="area0">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Top-Right</div>
        <div class="stat-value" id="area1">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Bottom-Left</div>
        <div class="stat-value" id="area2">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Bottom-Right</div>
        <div class="stat-value" id="area3">-</div>
      </div>
    </div>
</div>
        <div class="info-text">
      üí° Kierr√§ palaa klikkaamalla ja sijoita laudalle. Tavoite: jokainen nelj√§st√§ 3√ó3-alueesta muodostaa kelvollisen nopan silm√§luvun (1‚Äì6).
    </div>
    <div class="info-text" id="statusText" style="margin-top:10px;">
      Status: ‚Äì
    </div>
  </div>
</div>

<script>
  // Function to rotate a shape 90 degrees clockwise
  function rotateShape(shape) {
    const minR = Math.min(...shape.map(c => c.r));
    const maxR = Math.max(...shape.map(c => c.r));
    const minC = Math.min(...shape.map(c => c.c));
    const maxC = Math.max(...shape.map(c => c.c));
    
    const h = maxR - minR + 1;
    const w = maxC - minC + 1;
    
    const rotated = shape.map(cell => ({
      r: cell.c - minC,
      c: h - 1 - (cell.r - minR),
      dot: cell.dot
    }));
    
    return rotated;
  }

  // Generate all rotations for a piece
  function generateAllRotations(baseShape) {
    const rotations = [baseShape];
    let current = baseShape;
    for (let i = 0; i < 3; i++) {
      current = rotateShape(current);
      rotations.push(current);
    }
    // Remove duplicate rotations
    return rotations.filter((rot, idx, arr) => 
      idx === 0 || JSON.stringify(rot) !== JSON.stringify(arr[idx - 1])
    );
  }

  // Piece definitions: base shape only
  const PIECE_DEFINITIONS = [
    // oo (0 dots)
    { name: 'oo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:false}]},
    // ox (1 dot)
    { name: 'ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}]},
    // xx (2 dots)
    { name: 'xx', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:true}]},
    // xoo (1 dot)
    { name: 'xoo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}]},
    // xox (2 dots)
    { name: 'xox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:true}]},
    // xoox (2 dots)
    { name: 'xoox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:0,c:2,dot:false}, {r:0,c:3,dot:true}]},
    // ox/oo 2√ó2 (1 dot)
    { name: 'ox/oo', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}]},
    // xo/ox 2√ó2 (2 dots)
    { name: 'xo/ox', base: [{r:0,c:0,dot:true}, {r:0,c:1,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:true}]},
    // oxo/ooo 2√ó3 (1 dot)
    { name: 'oxo/ooo', base: [{r:0,c:0,dot:false}, {r:0,c:1,dot:true}, {r:0,c:2,dot:false}, {r:1,c:0,dot:false}, {r:1,c:1,dot:false}, {r:1,c:2,dot:false}]}
  ];

  // Create pieces: 4√óoo + others
  let pieces = [];
  let pieceId = 0;
  for (let i = 0; i < 4; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[0].base);
    pieces.push({ 
      id: pieceId++, 
      name: 'oo', 
      rotation: 0, 
      shapes: shapes
    });
  }
  for (let i = 1; i < PIECE_DEFINITIONS.length; i++) {
    const shapes = generateAllRotations(PIECE_DEFINITIONS[i].base);
    pieces.push({ 
      id: pieceId++, 
      name: PIECE_DEFINITIONS[i].name, 
      rotation: 0, 
      shapes: shapes
    });
  }

  const board = Array(36).fill(null); // 6√ó6
  let selectedPiece = null;
  let solved = false;
  let activePuzzle = null; // currently loaded puzzle (for arrow hints)

  const lockedPieceIds = new Set();

  const boardEl = document.getElementById('boardFrame');
  const piecesGridEl = document.getElementById('piecesGrid');
  const resetBtn = document.getElementById('resetBtn');
  const solveBtn = document.getElementById('solveBtn');

  const puzzleSelect = document.getElementById('puzzleSelect');
  const statusEl = document.getElementById('statusText');

// --- Dice face validation (3√ó3 area -> 1..6, rotation independent) ---
const DIE_PATTERNS = (() => {
  // 3√ó3 coordinates (r,c) with pips
  const base = {
    1: [[1,1]],
    2: [[0,0],[2,2]],
    3: [[0,0],[1,1],[2,2]],
    4: [[0,0],[0,2],[2,0],[2,2]],
    5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
    6: [[0,0],[1,0],[2,0],[0,2],[1,2],[2,2]],
  };

  const rot = (rc) => rc.map(([r,c]) => [c, 2 - r]); // 90¬∞ CW in 3√ó3
  const keyOf = (rc) => rc
    .map(([r,c]) => `${r},${c}`)
    .sort()
    .join("|");

  const map = new Map(); // key -> value
  for (const [valStr, coords] of Object.entries(base)) {
    const val = Number(valStr);
    let cur = coords;
    for (let k=0;k<4;k++){
      map.set(keyOf(cur), val);
      cur = rot(cur);
    }
  }
  return map;
})();

function getAreaCells(areaIndex){
  const startRow = (areaIndex < 2) ? 0 : 3;
  const startCol = (areaIndex % 2 === 0) ? 0 : 3;
  const cells = [];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      cells.push(board[(startRow+r)*6 + (startCol+c)]);
    }
  }
  return cells;
}

function getDieValueFromArea(areaIndex){
  const startRow = (areaIndex < 2) ? 0 : 3;
  const startCol = (areaIndex % 2 === 0) ? 0 : 3;

  const dots = [];
  let anyFilled = false;

  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const cell = board[(startRow + r) * 6 + (startCol + c)];
      if (cell !== null) anyFilled = true;
      if (cell && cell.dot) dots.push([r,c]);
    }
  }

  if (!anyFilled) return null; // completely empty area -> show "-"
  const key = dots.map(([r,c]) => `${r},${c}`).sort().join("|");
  return DIE_PATTERNS.get(key) ?? 0; // 0 = invalid
}


function getArrowCheck(type, index, targetSum){
  // Returns: {state:"pending"|"ok"|"bad", currentSum:number|null}
  const TL = getDieValueFromArea(0);
  const TR = getDieValueFromArea(1);
  const BL = getDieValueFromArea(2);
  const BR = getDieValueFromArea(3);

  if (type === "row"){
    const top = index < 3;
    const a = top ? TL : BL;
    const b = top ? TR : BR;
    if (!a || !b) return {state:"pending", currentSum:null}; // null or 0 -> pending/invalid
    const s = a + b;
    return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
  }

  if (type === "column"){
    const left = index < 3;
    const a = left ? TL : TR;
    const b = left ? BL : BR;
    if (!a || !b) return {state:"pending", currentSum:null};
    const s = a + b;
    return {state: (s === targetSum ? "ok" : "bad"), currentSum:s};
  }

  return {state:"pending", currentSum:null};
}

function updateStats() {
  for (let i = 0; i < 4; i++) {
    const v = getDieValueFromArea(i);
    let out = "-";
    if (v === 0) out = "√ó";     // invalid
    else if (v !== null) out = String(v);
    document.getElementById(`area${i}`).textContent = out;
  }
}

function setStatus(msg){
  if (statusEl) statusEl.textContent = `Status: ${msg}`;
}

function checkWin(){
  const allFilled = board.every(x => x !== null);
  const vals = [0,1,2,3].map(getDieValueFromArea);
  const allValid = vals.every(v => v >= 1 && v <= 6);

  if (allFilled && allValid){
    if (!solved){
      solved = true;
      setStatus("‚úÖ Valmis! (Reset Board aloittaa alusta)");
    }
    return true;
  }
  solved = false;

  if (!allFilled){
    setStatus("Kesken: t√§yt√§ lauta ja muodosta 4 kelvollista noppaa.");
  } else if (!allValid){
    setStatus("Kesken: jokaisen 3√ó3-alueen pit√§√§ olla kelvollinen noppa (1‚Äì6).");
  } else {
    setStatus("Kesken.");
  }
  return false;
}

  function getCurrentShape(piece) {
    return piece.shapes[piece.rotation % piece.shapes.length];
  }

  function canPlace(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      if (r < 0 || r >= 6 || c < 0 || c >= 6) return false;
      if (board[r * 6 + c] !== null) return false;
    }
    return true;
  }

  function placePiece(piece, startRow, startCol) {
    const shape = getCurrentShape(piece);
    for (const cell of shape) {
      const r = startRow + cell.r;
      const c = startCol + cell.c;
      const idx = r * 6 + c;
      board[idx] = { pieceId: piece.id, dot: cell.dot };
    }
  }

  function removePiece(piece) {
    for (let i = 0; i < 36; i++) {
      if (board[i] && board[i].pieceId === piece.id) {
        board[i] = null;
      }
    }
  }

  function isPiecePlaced(piece) {
    return board.some(cell => cell && cell.pieceId === piece.id);
  }

  
function renderBoard() {
    boardEl.innerHTML = '';

    // Build quick lookup maps for arrow hints (row/column -> {sum, dir})
    const rowHints = new Map();
    const colHints = new Map();
    if (activePuzzle && Array.isArray(activePuzzle.arrows)) {
      for (const a of activePuzzle.arrows) {
        if (a.type === "row") rowHints.set(a.index, a);
        if (a.type === "column") colHints.set(a.index, a);
      }
    }

    // 7√ó7 frame: 6√ó6 cells + extra row/col for hints
    for (let r = 0; r < 7; r++) {
      for (let c = 0; c < 7; c++) {

        // Corner (bottom-right) = empty
        if (r === 6 && c === 6) {
          const h = document.createElement('div');
          h.className = 'hint empty';
          boardEl.appendChild(h);
          continue;
        }

        // Row hints live in the 7th column (c==6), aligned with rows 0..5
        if (c === 6 && r < 6) {
          const h = document.createElement('div');
          const hint = rowHints.get(r);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "left" ? "‚Üê " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("row", r, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        // Column hints live in the 7th row (r==6), aligned with columns 0..5
        if (r === 6 && c < 6) {
          const h = document.createElement('div');
          const hint = colHints.get(c);
          h.className = hint ? 'hint' : 'hint empty';
          h.textContent = hint ? ((hint.direction === "up" ? "‚Üë " : "") + String(hint.sum)) : '';
          if (hint) {
            const chk = getArrowCheck("column", c, hint.sum);
            if (chk.state === "ok") h.classList.add("ok");
            else if (chk.state === "bad") h.classList.add("bad");
          }
          boardEl.appendChild(h);
          continue;
        }

        // Normal board cell (0..5, 0..5)
        const cell = document.createElement('div');
        cell.className = 'cell';

        const bidx = r * 6 + c;
        if (board[bidx]) {
          cell.classList.add('occupied');

          // Piece outline helpers (only for the 6√ó6 main board)
          const pid = board[bidx].pieceId;
          if (pid !== undefined && pid !== null) {
            cell.classList.add('piece');

            // Determine which edges are on the piece boundary
            const same = (rr, cc) => {
              if (rr < 0 || rr >= 6 || cc < 0 || cc >= 6) return false;
              const n = board[rr * 6 + cc];
              return !!n && n.pieceId === pid;
            };

            // Use CSS variables so multiple edges can be drawn at once
            cell.style.setProperty('--pt', same(r-1, c) ? '0px' : '3px');
            cell.style.setProperty('--pr', same(r, c+1) ? '0px' : '3px');
            cell.style.setProperty('--pb', same(r+1, c) ? '0px' : '3px');
            cell.style.setProperty('--pl', same(r, c-1) ? '0px' : '3px');
          }

          if (board[bidx].dot) cell.textContent = '‚óè';
        }

        cell.addEventListener('click', () => placePieceOnBoard(r, c));
        boardEl.appendChild(cell);
      }
    }

    updateStats();
    checkWin();
  }


  function placePieceOnBoard(r, c) {
    const idx = r * 6 + c;
    if (solved) return;
    // If cell is occupied, remove the piece (unless locked)
    if (board[idx] !== null) {
      const pieceId = board[idx].pieceId;
      if (lockedPieceIds.has(pieceId)) return;
      const pieceIdx = pieces.findIndex(p => p.id === pieceId);
      if (pieceIdx !== -1) {
        removePiece(pieces[pieceIdx]);
        renderBoard();
        renderPieces();
      }
      return;
    }

    // Otherwise, place selected piece
    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];

    // Locked pieces (loaded from a puzzle) cannot be moved
    if (lockedPieceIds.has(piece.id) && isPiecePlaced(piece)) return;

    if (canPlace(piece, r, c)) {
      removePiece(piece);
      placePiece(piece, r, c);
      renderBoard();
      renderPieces();
    }
  }

  function renderPieces() {
    piecesGridEl.innerHTML = '';
    pieces.forEach((piece, idx) => {
      const btn = document.createElement('button');
      btn.className = 'piece-btn';
      if (selectedPiece === idx) btn.classList.add('selected');
      if (isPiecePlaced(piece)) btn.classList.add('used');
      
      const shape = getCurrentShape(piece);
      const minR = Math.min(...shape.map(c => c.r));
      const maxR = Math.max(...shape.map(c => c.r));
      const minC = Math.min(...shape.map(c => c.c));
      const maxC = Math.max(...shape.map(c => c.c));
      
      const cols = maxC - minC + 1;
let previewHtml = `<div class="piece-preview" style="--cols:${cols};">`;
      for (let r = minR; r <= maxR; r++) {
        for (let c = minC; c <= maxC; c++) {
          const hasCell = shape.some(cell => cell.r === r && cell.c === c);
          const hasDot = shape.some(cell => cell.r === r && cell.c === c && cell.dot);
          if (hasCell) {
            previewHtml += `<div class="piece-preview-cell ${hasDot ? 'dot' : ''}"></div>`;
          } else {
            previewHtml += `<div class="piece-preview-cell empty"></div>`;
          }
        }
      }
      previewHtml += '</div>';
      
      btn.innerHTML = previewHtml + `<div class="piece-info">${piece.name}</div>`;
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (solved) return;

        // Locked pieces (loaded from a puzzle) cannot be selected/rotated/moved
        if (lockedPieceIds.has(piece.id)) return;

        if (selectedPiece === idx) {
          // Second click on same piece: rotate
          rotatePiece();
        } else {
          // First click: select piece
          selectedPiece = idx;
        }
        renderPieces();
      });
      piecesGridEl.appendChild(btn);
    });
  }

  function rotatePiece() {
    if (solved) return;
    if (selectedPiece === null) return;
    const piece = pieces[selectedPiece];
    piece.rotation = (piece.rotation + 1) % piece.shapes.length;
    renderPieces();
  }
  // ---- Puzzles loaded from dice_deduction_puzzles.json ----
let PUZZLE_DB = null;

async function loadPuzzleFile() {
  try {
    const res = await fetch("dice_deduction_puzzles.json", { cache: "no-store" });
    if (!res.ok) throw new Error(res.status);
    PUZZLE_DB = await res.json();

    populatePuzzleSelect();

    // lataa oletuspulma
    if (PUZZLE_DB.puzzles?.length) {
      puzzleSelect.value = String(PUZZLE_DB.puzzles[0].id);
      loadPuzzle(PUZZLE_DB.puzzles[0]);
    }

    setStatus(`Loaded ${PUZZLE_DB.puzzles.length} puzzles`);
  } catch (err) {
    console.error("Puzzle load failed", err);
    setStatus("‚ùå Puzzle file not loaded");
  }
}

  function puzzleLabel(p) {
    const title = (p.title || "").trim();
    const base = `#${p.id} ‚Ä¢ ${p.difficulty || "?"}`;
    return title ? `${base} ‚Ä¢ ${title}` : base;
  }
function clearLocked() {
    lockedPieceIds.clear();
  }

  function findUnusedPieceByName(name) {
    const usedIds = new Set(board.filter(x => x).map(x => x.pieceId));
    return pieces.find(p => p.name === name && !usedIds.has(p.id));
  }

  function loadPuzzle(puz) {
    // Clear board + reset piece rotations
    for (let i = 0; i < 36; i++) board[i] = null;
    for (let p of pieces) p.rotation = 0;
    selectedPiece = null;
    solved = false;
    clearLocked();

    activePuzzle = puz;
    // Place locked pieces
    for (const lp of puz.lockedPieces || []) {
      const piece = findUnusedPieceByName(lp.piece);
      if (!piece) {
        console.warn("No unused piece found for", lp.piece);
        continue;
      }
      piece.rotation = lp.rotation || 0;

      if (!canPlace(piece, lp.row, lp.col)) {
        console.warn("Cannot place locked piece", lp, "with current rotation. Skipping.");
        continue;
      }
      placePiece(piece, lp.row, lp.col);
      lockedPieceIds.add(piece.id);
    }

    renderBoard();
    renderPieces();
    setStatus(`Loaded puzzle #${puz.id} (${puz.difficulty}). Locked pieces: ${lockedPieceIds.size}.`);
  }
function resetBoard() {
	    solved = false;
	    selectedPiece = null;

	    // Always clear the board + reset rotations
	    for (let i = 0; i < 36; i++) board[i] = null;
	    for (let piece of pieces) piece.rotation = 0;

	    if (!activePuzzle) {
	      // Free build mode: clear everything (also any stale lock state)
	      clearLocked();
	      setStatus("‚Äì");
	    } else {
	      // Puzzle mode: keep the puzzle's locked pieces, remove only player pieces
	      clearLocked();
	      for (const lp of activePuzzle.lockedPieces || []) {
	        const piece = findUnusedPieceByName(lp.piece);
	        if (!piece) continue;
	        piece.rotation = lp.rotation || 0;
	        if (canPlace(piece, lp.row, lp.col)) {
	          placePiece(piece, lp.row, lp.col);
	          lockedPieceIds.add(piece.id);
	        }
	      }
	      setStatus(`Reset: puzzle #${activePuzzle.id} (${activePuzzle.difficulty}). Locked pieces restored: ${lockedPieceIds.size}.`);
	    }

	    renderBoard();
	    renderPieces();
	  }
  
/* -------------------- SOLVER (Ratkaise) --------------------
   T√§ytt√§√§ laudan automaattisesti (lukitut palat s√§ilyv√§t).
   Solver tekee exact-tiling backtrackingin ja tarkistaa:
   - jokainen 3√ó3-alue voi muodostaa kelvollisen nopan (1‚Äì6)
   - nuolivihjeet t√§sm√§√§v√§t kun niihin liittyv√§t nopat ovat valmiit
------------------------------------------------------------ */

function buildDiePatternSets(){
  // patternsByValue[v] = array of Set("r,c")
  const patternsByValue = {1:[],2:[],3:[],4:[],5:[],6:[]};
  for (const [key, val] of DIE_PATTERNS.entries()){
    const s = new Set(key ? key.split("|") : []);
    patternsByValue[val].push(s);
  }
  // dedupe sets per value
  for (const v of [1,2,3,4,5,6]){
    const seen = new Set();
    patternsByValue[v] = patternsByValue[v].filter(s=>{
      const k = [...s].sort().join("|");
      if(seen.has(k)) return false;
      seen.add(k);
      return true;
    });
  }
  return patternsByValue;
}
const DIE_PATTERN_SETS = buildDiePatternSets();

function areaIndexOfCell(r,c){
  // 0=TL,1=TR,2=BL,3=BR
  const top = r < 3;
  const left = c < 3;
  if(top && left) return 0;
  if(top && !left) return 1;
  if(!top && left) return 2;
  return 3;
}

function getAreaInfoFromBoard(b, areaIndex){
  const startRow = (areaIndex < 2) ? 0 : 3;
  const startCol = (areaIndex % 2 === 0) ? 0 : 3;

  let anyFilled = false;
  let allFilled = true;
  const dots = [];
  const empties = [];

  for(let rr=0; rr<3; rr++){
    for(let cc=0; cc<3; cc++){
      const cell = b[(startRow+rr)*6 + (startCol+cc)];
      if(cell !== null) anyFilled = true;
      else allFilled = false;

      // cell.dot tells whether this occupied cell is a pip
      if(cell){
        if(cell.dot) dots.push(`${rr},${cc}`);
        else empties.push(`${rr},${cc}`);
      }
    }
  }

  const dotSet = new Set(dots);
  const emptySet = new Set(empties);
  return { anyFilled, allFilled, dotSet, emptySet };
}


function areaDotsSubsetPossible(dotSet){
  // empty dot set is always possible (it can become 1..6 later)
  if(dotSet.size === 0) return true;

  // must be subset of at least one die pattern (1..6)
  for(const v of [1,2,3,4,5,6]){
    for(const pat of DIE_PATTERN_SETS[v]){
      let ok = true;
      for(const d of dotSet){
        if(!pat.has(d)){ ok = false; break; }
      }
      if(ok) return true;
    }
  }
  return false;
}

function getDieValueFromBoard(b, areaIndex){
  const info = getAreaInfoFromBoard(b, areaIndex);
  // Only define a die value when the 3√ó3 area is complete.
  // Partial fillings must NOT be treated as invalid (they may still become a valid face).
  if(!info.allFilled) return null;

  const key = [...info.dotSet].sort().join("|");
  return DIE_PATTERNS.get(key) ?? 0; // 0 means: complete but invalid
}

function arrowsSatisfiedIfDetermined_original(b){
  if(!activePuzzle || !Array.isArray(activePuzzle.arrows)) return true;

  // Only enforce an arrow when the two related 3√ó3 areas are fully filled.
  const areaFilled = [0,1,2,3].map(i => getAreaInfoFromBoard(b,i).allFilled);
  const areaVal    = [0,1,2,3].map(i => getDieValueFromBoard(b,i));

  for(const a of activePuzzle.arrows){
    if(a.type === "row"){
      const top = a.index < 3;
      const ai = top ? 0 : 2;
      const bi = top ? 1 : 3;
      if(areaFilled[ai] && areaFilled[bi]){
        const va = areaVal[ai], vb = areaVal[bi];
        if(!(va>=1 && va<=6 && vb>=1 && vb<=6)) return false;
        if(va + vb !== a.sum) return false;
      }
    } else if(a.type === "column"){
      const left = a.index < 3;
      const ai = left ? 0 : 1;
      const bi = left ? 2 : 3;
      if(areaFilled[ai] && areaFilled[bi]){
        const va = areaVal[ai], vb = areaVal[bi];
        if(!(va>=1 && va<=6 && vb>=1 && vb<=6)) return false;
        if(va + vb !== a.sum) return false;
      }
    }
  }
  return true;
}


function arrowsSatisfiedIfDetermined(b){
  // kept for existing calls
  return arrowsSatisfiedIfDetermined_original(b);
}


function collectPairSums(){
  // Collapse per-row/per-col hints (they are repeated for the 3 rows/cols that form one 3√ó3 die)
  // Returns {topRowSum, bottomRowSum, leftColSum, rightColSum} where each is number|null
  const out = {topRowSum:null, bottomRowSum:null, leftColSum:null, rightColSum:null};
  if(!activePuzzle || !Array.isArray(activePuzzle.arrows)) return out;

  for(const a of activePuzzle.arrows){
    if(a.type === "row"){
      const key = (a.index < 3) ? "topRowSum" : "bottomRowSum";
      if(out[key] == null) out[key] = a.sum;
      else if(out[key] !== a.sum) return { ...out, _inconsistent:true };
    } else if(a.type === "column"){
      const key = (a.index < 3) ? "leftColSum" : "rightColSum";
      if(out[key] == null) out[key] = a.sum;
      else if(out[key] !== a.sum) return { ...out, _inconsistent:true };
    }
  }
  return out;
}

function areaPossibleMaskFromAreaInfo(info){
  // bit i (0..5) means value (i+1) is still possible for this 3√ó3 area
  // We use BOTH positive info (known dots) and negative info (known empties).
  //
  // Examples that fall out automatically:
  // - Center dot => only 1,3,5 possible
  // - Center empty => only 2,4,6 possible
  // - Corner dot implies opposite corner dot (diagonal symmetry)
  // because those are properties of valid die faces.
  if(!info.anyFilled){
    return 0b111111; // nothing known yet
  }

  let mask = 0;
  for(const v of [1,2,3,4,5,6]){
    const patterns = DIE_PATTERN_SETS[v];
    let ok = false;

    for(const pat of patterns){
      // Must include all known dots
      let good = true;
      for(const d of info.dotSet){
        if(!pat.has(d)){ good = false; break; }
      }
      if(!good) continue;

      // Must NOT include any known empty pip positions
      for(const e of info.emptySet){
        if(pat.has(e)){ good = false; break; }
      }
      if(good){ ok = true; break; }
    }

    if(ok) mask |= (1 << (v-1));
  }
  return mask;
}

function pairSumFeasible(maskA, maskB, target){

  for(let va=1; va<=6; va++){
    if(!(maskA & (1<<(va-1)))) continue;
    const vb = target - va;
    if(vb>=1 && vb<=6 && (maskB & (1<<(vb-1)))) return true;
  }
  return false;
}

function totalSum12Feasible(m0,m1,m2,m3){
  // Check existence of (a,b,c,d) with a+b+c+d = 12
  // Small domains (<=6) -> brute force is fine and fast.
  for(let a=1;a<=6;a++){
    if(!(m0 & (1<<(a-1)))) continue;
    for(let b=1;b<=6;b++){
      if(!(m1 & (1<<(b-1)))) continue;
      const ab = a+b;
      if(ab > 12) continue;
      for(let c=1;c<=6;c++){
        if(!(m2 & (1<<(c-1)))) continue;
        const abc = ab+c;
        if(abc > 12) continue;
        const d = 12 - abc;
        if(d>=1 && d<=6 && (m3 & (1<<(d-1)))) return true;
      }
    }
  }
  return false;
}

function boardConsistent(b){
  // Build possible value masks for each 3√ó3 area from current dots (partial info allowed)
  const areaInfo = [0,1,2,3].map(i => getAreaInfoFromBoard(b,i));
  const areaMasks = [0,1,2,3].map(i => areaPossibleMaskFromAreaInfo(areaInfo[i]));

  // If any area can no longer become any die face -> dead
  for(const m of areaMasks){
    if(m === 0) return false;
  }

  // If an area is fully filled, it must already be a valid die (mask must include that exact value)
  for(let i=0;i<4;i++){
    if(areaInfo[i].allFilled){
      const v = getDieValueFromBoard(b,i);
      if(!(v>=1 && v<=6)) return false;
      if(!(areaMasks[i] & (1<<(v-1)))) return false;
      areaMasks[i] = (1<<(v-1)); // fix it
    }
  }

  // --- NEW SPEEDUP: use the invariant "all four dice sum to 12" + implied pair-sums ---
  const sums = collectPairSums();
  if(sums._inconsistent) return false;

  // If one horizontal sum is given, the other is implied by total 12 (and vice versa)
  const topSum    = (sums.topRowSum    != null) ? sums.topRowSum    : (sums.bottomRowSum != null ? (12 - sums.bottomRowSum) : null);
  const bottomSum = (sums.bottomRowSum != null) ? sums.bottomRowSum : (sums.topRowSum    != null ? (12 - sums.topRowSum)    : null);

  // If one vertical sum is given, the other is implied by total 12 (and vice versa)
  const leftSum   = (sums.leftColSum   != null) ? sums.leftColSum   : (sums.rightColSum  != null ? (12 - sums.rightColSum)  : null);
  const rightSum  = (sums.rightColSum  != null) ? sums.rightColSum  : (sums.leftColSum   != null ? (12 - sums.leftColSum)   : null);

  // Enforce pair feasibility early (even when areas are not fully filled yet)
  if(topSum != null && !pairSumFeasible(areaMasks[0], areaMasks[1], topSum)) return false;
  if(bottomSum != null && !pairSumFeasible(areaMasks[2], areaMasks[3], bottomSum)) return false;
  if(leftSum != null && !pairSumFeasible(areaMasks[0], areaMasks[2], leftSum)) return false;
  if(rightSum != null && !pairSumFeasible(areaMasks[1], areaMasks[3], rightSum)) return false;

  // Enforce global total sum = 12 feasibility (very strong prune)
  if(!totalSum12Feasible(areaMasks[0], areaMasks[1], areaMasks[2], areaMasks[3])) return false;

  // Keep the original arrow constraints check, but only when both related areas are complete
  if(!arrowsSatisfiedIfDetermined_original(b)) return false;

  return true;
}

function canPlaceOn(b, piece, startRow, startCol, rotIndex){
  const shape = piece.shapes[rotIndex % piece.shapes.length];
  for(const cell of shape){
    const r = startRow + cell.r;
    const c = startCol + cell.c;
    if(r<0 || r>=6 || c<0 || c>=6) return false;
    if(b[r*6+c] !== null) return false;
  }
  return true;
}

function placePieceOn(b, piece, startRow, startCol, rotIndex){
  const shape = piece.shapes[rotIndex % piece.shapes.length];
  for(const cell of shape){
    const r = startRow + cell.r;
    const c = startCol + cell.c;
    b[r*6+c] = { pieceId: piece.id, dot: cell.dot };
  }
}

function removePieceFrom(b, pieceId){
  for(let i=0;i<36;i++){
    if(b[i] && b[i].pieceId === pieceId) b[i] = null;
  }
}

function cloneBoard(b){
  // shallow clone is enough (cells are small objects)
  return b.map(x => x ? {pieceId:x.pieceId, dot:x.dot} : null);
}

function getPlacementsForPiece(b, piece){
  const placements = [];
  for(let rot=0; rot<piece.shapes.length; rot++){
    // quick bounding box to reduce loops
    const shape = piece.shapes[rot];
    const maxR = Math.max(...shape.map(c=>c.r));
    const maxC = Math.max(...shape.map(c=>c.c));
    for(let r=0; r<=6-(maxR+1); r++){
      for(let c=0; c<=6-(maxC+1); c++){
        if(canPlaceOn(b, piece, r, c, rot)){
          placements.push({r,c,rot});
        }
      }
    }
  }
  return placements;
}

function pickNextPiece(b, remainingPieces){
  // MRV: choose piece with fewest placements
  let bestIdx = -1;
  let bestPlacements = null;

  for(let i=0;i<remainingPieces.length;i++){
    const p = remainingPieces[i];
    const pl = getPlacementsForPiece(b, p);
    if(pl.length === 0) return { idx:i, placements:[] }; // dead end
    if(bestIdx === -1 || pl.length < bestPlacements.length){
      bestIdx = i;
      bestPlacements = pl;
      if(pl.length === 1) break;
    }
  }
  return { idx: bestIdx, placements: bestPlacements || [] };
}

function solveBacktrack(b, remainingPieces){
  if(!boardConsistent(b)) return null;

  if(remainingPieces.length === 0){
    // Final check: all areas must be valid die 1..6 and arrows must match
    for(let i=0;i<4;i++){
      const v = getDieValueFromBoard(b,i);
      if(!(v>=1 && v<=6)) return null;
      const info = getAreaInfoFromBoard(b,i);
      if(!info.allFilled) return null;
    }
    if(!arrowsSatisfiedIfDetermined(b)) return null;
    return b;
  }

  const pick = pickNextPiece(b, remainingPieces);
  if(pick.idx < 0 || pick.placements.length === 0) return null;

  const piece = remainingPieces[pick.idx];
  const rest = remainingPieces.slice(0, pick.idx).concat(remainingPieces.slice(pick.idx+1));

  // Slight ordering: try placements that touch already-filled cells first (tends to speed up)
  const scoreTouch = (pl)=>{
    let s = 0;
    const shape = piece.shapes[pl.rot];
    for(const cell of shape){
      const r = pl.r + cell.r, c = pl.c + cell.c;
      const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
      for(const [rr,cc] of neigh){
        if(rr<0||rr>=6||cc<0||cc>=6) continue;
        if(b[rr*6+cc] !== null) s++;
      }
    }
    return -s; // more touches first
  };
  pick.placements.sort((a,b2)=> scoreTouch(a)-scoreTouch(b2));

  for(const pl of pick.placements){
    const nb = cloneBoard(b);
    placePieceOn(nb, piece, pl.r, pl.c, pl.rot);

    const solvedB = solveBacktrack(nb, rest);
    if(solvedB) return solvedB;
  }
  return null;
}

function solveCurrentPuzzle(){
  if(!activePuzzle){
    alert("Valitse ensin pulma.");
    return;
  }

  // Ratkaisu tehd√§√§n puhtaasta puzzle-tilasta (lukitut palat), jotta pelaajan virheet eiv√§t est√§ ratkaisua.
  resetBoard();

  // Rakennetaan solverin l√§ht√∂lauta (sis√§lt√§√§ lukitut)
  const startBoard = cloneBoard(board);

  // Lista ei-lukituista paloista
  const locked = new Set(lockedPieceIds);
  const remaining = pieces.filter(p => !locked.has(p.id));

  setStatus("‚è≥ Ratkaistaan‚Ä¶");

  // Pieni viive, jotta status ehtii p√§ivitty√§ iOS:ll√§kin
  setTimeout(()=>{
    const result = solveBacktrack(startBoard, remaining);

    if(!result){
      setStatus("‚ùå Ratkaisua ei l√∂ytynyt (tarkista pulman tiedot).");
      return;
    }

    // Kopioi ratkaisu globaaliin boardiin
    for(let i=0;i<36;i++){
      board[i] = result[i] ? { pieceId: result[i].pieceId, dot: result[i].dot } : null;
    }

    // Merkit√§√§n ratkaistuksi ja p√§ivitet√§√§n UI
    solved = true;
    selectedPiece = null;

    renderBoard();
    renderPieces();

    setStatus("‚úÖ Ratkaisu n√§ytetty. (Nollaa aloittaa alusta)");
  }, 0);
}

function populatePuzzleSelect(){
    if(!puzzleSelect) return;
    puzzleSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Valitse pulma‚Ä¶";
    puzzleSelect.appendChild(opt0);

    for (const p of (PUZZLE_DB.puzzles || [])){
      const opt = document.createElement("option");
      opt.value = String(p.id);
      opt.textContent = puzzleLabel(p);
      puzzleSelect.appendChild(opt);
    }
  }

  resetBtn.addEventListener('click', resetBoard);
  solveBtn.addEventListener('click', (e)=>{ e.preventDefault(); solveCurrentPuzzle(); });


puzzleSelect.addEventListener("change", ()=>{
  if (!PUZZLE_DB) return;
  const id = Number(puzzleSelect.value);
  if(!id) return;
  const puz = PUZZLE_DB.puzzles.find(p => p.id === id);
  if (puz) loadPuzzle(puz);
});


document.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      rotatePiece();
    }
  });
loadPuzzleFile();

  renderBoard();
  renderPieces();
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./service-worker.js").catch(console.error);
    });
  }
</script>

</body>
</html>